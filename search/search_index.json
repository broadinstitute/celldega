{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Celldega's Documentation","text":"Celldega Landscape visualization of a human skin cancer Xenium dataset obtained from 10X Genomics.  <p>Celldega is a spatial analysis and visualization library that is being developed by the Spatial Technology Platform at the Broad Institute of MIT and Harvard. This project enables researchers to easily visualize large ST datasets (e.g., datasets with &gt;100M transcripts) alongside single-cell and spatial analysis notebook workflows (e.g., sverse tools and novel spatial analysis approaches).</p> <ul> <li>Getting Started</li> <li>Installation</li> <li>Usage</li> </ul>"},{"location":"#whats-new","title":"What's New","text":"<p>The project was recently presented at the Broad Retreat Data Visualization Breakout Session -</p> <p> </p>"},{"location":"#about","title":"About","text":"<p>Celldega is named after a bodega, a small shop with all the essentials that is part of the fabric of a neighborhood.</p>"},{"location":"examples/","title":"Jupyter Notebook Examples","text":""},{"location":"examples/#brief-notebooks","title":"Brief Notebooks","text":"<p>Landscape View Xenium</p> <p>Mouse-Brain_Alpha-Shape-Neighborhood</p>"},{"location":"examples/brief_notebooks/Celldega-heatmap/","title":"Celldega heatmap","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n%env ANYWIDGET_HMR=1\n</pre> %load_ext autoreload %autoreload 2 %env ANYWIDGET_HMR=1 <pre>env: ANYWIDGET_HMR=1\n</pre> In\u00a0[2]: Copied! <pre># macOS requirement\nimport os\nos.environ['DYLD_LIBRARY_PATH'] = '/opt/homebrew/lib:' + os.environ.get('DYLD_LIBRARY_PATH', '')\n</pre> # macOS requirement import os os.environ['DYLD_LIBRARY_PATH'] = '/opt/homebrew/lib:' + os.environ.get('DYLD_LIBRARY_PATH', '') In\u00a0[3]: Copied! <pre>from ipywidgets import HBox, Layout, GridBox\n</pre> from ipywidgets import HBox, Layout, GridBox In\u00a0[4]: Copied! <pre>import celldega as dega\nfrom ipywidgets import Widget\n</pre> import celldega as dega from ipywidgets import Widget In\u00a0[5]: Copied! <pre>from clustergrammer2 import Network, CGM2\nimport pandas as pd\nimport numpy as np\n</pre> from clustergrammer2 import Network, CGM2 import pandas as pd import numpy as np <pre>&gt;&gt; clustergrammer2 backend version 0.18.0\n</pre> In\u00a0[6]: Copied! <pre># generate random matrix\nnum_rows = 10\nnum_cols = 10\n\nnp.random.seed(seed=100)\nmat = np.random.rand(num_rows, num_cols)\n\n# make row and col labels\nrows = range(num_rows)\ncols = range(num_cols)\nrows = ['row-' + str(i) for i in rows]\ncols = ['col-' + str(i) for i in cols]\n\n# make dataframe\ndf = pd.DataFrame(data=mat, columns=cols, index=rows)\ndf.shape\n\nnet = Network(CGM2)\nnet.load_df(df)\nnet.cluster()\nnetwork = net.viz\n</pre> # generate random matrix num_rows = 10 num_cols = 10  np.random.seed(seed=100) mat = np.random.rand(num_rows, num_cols)  # make row and col labels rows = range(num_rows) cols = range(num_cols) rows = ['row-' + str(i) for i in rows] cols = ['col-' + str(i) for i in cols]  # make dataframe df = pd.DataFrame(data=mat, columns=cols, index=rows) df.shape  net = Network(CGM2) net.load_df(df) net.cluster() network = net.viz In\u00a0[7]: Copied! <pre>base_path = 'data/visium-hd_data/Visium_HD_Mouse_Lung_Fresh_Frozen_binned_outputs/square_008um/landscape_files'\n\ndf_sig = pd.read_parquet(base_path + '/df_sig_marker.parquet')\ndf_sig.shape\n\nnet = Network(CGM2)\nnet.load_df(df_sig)\nnet.filter_N_top(axis='row', N_top=5000)\nnet.normalize(axis='col', norm_type='umi')\nnet.normalize(axis='row', norm_type='zscore')\nnet.cluster()\nnetwork = net.viz\n</pre> base_path = 'data/visium-hd_data/Visium_HD_Mouse_Lung_Fresh_Frozen_binned_outputs/square_008um/landscape_files'  df_sig = pd.read_parquet(base_path + '/df_sig_marker.parquet') df_sig.shape  net = Network(CGM2) net.load_df(df_sig) net.filter_N_top(axis='row', N_top=5000) net.normalize(axis='col', norm_type='umi') net.normalize(axis='row', norm_type='zscore') net.cluster() network = net.viz In\u00a0[10]: Copied! <pre>Widget.close_all()\nmat = dega.viz.MatrixNew(network=network, width=500, height=500)\nmat\n</pre> Widget.close_all() mat = dega.viz.MatrixNew(network=network, width=500, height=500) mat Out[10]: <pre>MatrixNew(height=500, network={'row_nodes': [{'name': 'Scgb1a1', 'ini': 635, 'clust': 149, 'rank': 224, 'rankv\u2026</pre> In\u00a0[12]: Copied! <pre>mat.click_info\n</pre> mat.click_info Out[12]: <pre>{'type': 'row_label', 'value': {'name': 'Actc1'}}</pre> In\u00a0[13]: Copied! <pre># # Example: Setting width to 'auto' or a specific value\n# mat_1.layout = Layout(width='500px')  # Adjust as needed\n# mat_2.layout = Layout(width='500px')  # Adjust as needed\n# widgets_side_by_side = HBox([mat_1, mat_2])\n# display(widgets_side_by_side)\n</pre> # # Example: Setting width to 'auto' or a specific value # mat_1.layout = Layout(width='500px')  # Adjust as needed # mat_2.layout = Layout(width='500px')  # Adjust as needed # widgets_side_by_side = HBox([mat_1, mat_2]) # display(widgets_side_by_side) In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/brief_notebooks/Landscape_View_Xenium/","title":"Landscape View Xenium","text":"In\u00a0[2]: Copied! <pre># %load_ext autoreload\n# %autoreload 2\n# %env ANYWIDGET_HMR=1\n</pre> # %load_ext autoreload # %autoreload 2 # %env ANYWIDGET_HMR=1 In\u00a0[3]: Copied! <pre>import celldega as dega\ndega.__version__\n</pre> import celldega as dega dega.__version__ Out[3]: <pre>'0.0.0'</pre> In\u00a0[6]: Copied! <pre>from observable_jupyter import embed\n</pre> from observable_jupyter import embed In\u00a0[11]: Copied! <pre>base_url = 'https://raw.githubusercontent.com/broadinstitute/celldega_Xenium_Prime_Mouse_Brain_Coronal_FF_outs/main/Xenium_Prime_Mouse_Brain_Coronal_FF_outs'\n</pre> base_url = 'https://raw.githubusercontent.com/broadinstitute/celldega_Xenium_Prime_Mouse_Brain_Coronal_FF_outs/main/Xenium_Prime_Mouse_Brain_Coronal_FF_outs' In\u00a0[14]: Copied! <pre>embed('@cornhundred/celldega-landscape-ist', inputs={'base_url': base_url}, cells=['landscape_container'], display_logo=False)\n</pre> embed('@cornhundred/celldega-landscape-ist', inputs={'base_url': base_url}, cells=['landscape_container'], display_logo=False) In\u00a0[13]: Copied! <pre># base_url = 'https://raw.githubusercontent.com/broadinstitute/celldega_Xenium_Prime_Human_Skin_FFPE_outs/main/Xenium_Prime_Human_Skin_FFPE_outs'\n\n# landscape_ist = dega.viz.Landscape(\n#     technology='Xenium',\n#     ini_zoom = -4.5,\n#     ini_x=6000,\n#     ini_y=8000,\n#     base_url = base_url,\n\n# )\n\n# landscape_ist\n</pre> # base_url = 'https://raw.githubusercontent.com/broadinstitute/celldega_Xenium_Prime_Human_Skin_FFPE_outs/main/Xenium_Prime_Human_Skin_FFPE_outs'  # landscape_ist = dega.viz.Landscape( #     technology='Xenium', #     ini_zoom = -4.5, #     ini_x=6000, #     ini_y=8000, #     base_url = base_url,  # )  # landscape_ist In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/brief_notebooks/Landscape_View_Xenium/#landscape-view-xenium","title":"Landscape View Xenium\u00b6","text":""},{"location":"examples/brief_notebooks/Mouse-Brain_Alpha-Shape-Neighborhood/","title":"Mouse Brain Alpha Shape Neighborhoods","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n%env ANYWIDGET_HMR=1\n</pre> %load_ext autoreload %autoreload 2 %env ANYWIDGET_HMR=1 <pre>env: ANYWIDGET_HMR=1\n</pre> In\u00a0[2]: Copied! <pre># macOS requirement\nimport os\nos.environ['DYLD_LIBRARY_PATH'] = '/opt/homebrew/lib:' + os.environ.get('DYLD_LIBRARY_PATH', '')\n</pre> # macOS requirement import os os.environ['DYLD_LIBRARY_PATH'] = '/opt/homebrew/lib:' + os.environ.get('DYLD_LIBRARY_PATH', '') In\u00a0[3]: Copied! <pre>from shapely import Point, MultiPoint, MultiPolygon\nimport geopandas as gpd\nimport numpy as np\nimport pandas as pd\nimport geopandas as gpd\nfrom libpysal.cg import alpha_shape\nimport matplotlib.pyplot as plt\nimport json\nfrom ipywidgets import Widget\nimport celldega as dega\n</pre> from shapely import Point, MultiPoint, MultiPolygon import geopandas as gpd import numpy as np import pandas as pd import geopandas as gpd from libpysal.cg import alpha_shape import matplotlib.pyplot as plt import json from ipywidgets import Widget import celldega as dega In\u00a0[4]: Copied! <pre>base_path = 'https://raw.githubusercontent.com/broadinstitute/celldega_Xenium_Prime_Mouse_Brain_Coronal_FF_outs/main/Xenium_Prime_Mouse_Brain_Coronal_FF_outs/'\n</pre> base_path = 'https://raw.githubusercontent.com/broadinstitute/celldega_Xenium_Prime_Mouse_Brain_Coronal_FF_outs/main/Xenium_Prime_Mouse_Brain_Coronal_FF_outs/' In\u00a0[5]: Copied! <pre>meta_cell_ini = pd.read_parquet(base_path + 'cell_metadata.parquet')\ncluster = pd.read_parquet(base_path + 'cell_clusters/cluster.parquet')\nmeta_cluster = pd.read_parquet(base_path + 'cell_clusters/meta_cluster.parquet')\nmeta_cell = pd.concat([meta_cell_ini, cluster], axis=1)\n</pre> meta_cell_ini = pd.read_parquet(base_path + 'cell_metadata.parquet') cluster = pd.read_parquet(base_path + 'cell_clusters/cluster.parquet') meta_cluster = pd.read_parquet(base_path + 'cell_clusters/meta_cluster.parquet') meta_cell = pd.concat([meta_cell_ini, cluster], axis=1) In\u00a0[6]: Copied! <pre>gdf_alpha = dega.nbhd.alpha_shape_cell_clusters(meta_cell, cat='cluster', alphas=[100, 150, 200, 250, 300, 350])\ngeojson_alpha = dega.nbhd.alpha_shape_geojson(gdf_alpha, meta_cluster, inst_alpha=250)\n</pre> gdf_alpha = dega.nbhd.alpha_shape_cell_clusters(meta_cell, cat='cluster', alphas=[100, 150, 200, 250, 300, 350]) geojson_alpha = dega.nbhd.alpha_shape_geojson(gdf_alpha, meta_cluster, inst_alpha=250) In\u00a0[7]: Copied! <pre>Widget.close_all()\nbase_url = base_path.rstrip('/')\nlandscape_ist = dega.viz.Landscape(\n    technology='Xenium',\n    ini_zoom = -4.5,\n    ini_x=6000,\n    ini_y=8000,\n    base_url = base_url,\n    nbhd=geojson_alpha\n)\n\nlandscape_ist\n</pre> Widget.close_all() base_url = base_path.rstrip('/') landscape_ist = dega.viz.Landscape(     technology='Xenium',     ini_zoom = -4.5,     ini_x=6000,     ini_y=8000,     base_url = base_url,     nbhd=geojson_alpha )  landscape_ist Out[7]: In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/brief_notebooks/Mouse-Brain_Alpha-Shape-Neighborhood/#mouse-brain-alpha-shape-neighborhoods","title":"Mouse Brain Alpha Shape Neighborhoods\u00b6","text":""},{"location":"examples/brief_notebooks/Mouse-Brain_Alpha-Shape-Neighborhood/#load-data","title":"Load Data\u00b6","text":""},{"location":"examples/brief_notebooks/Mouse-Brain_Alpha-Shape-Neighborhood/#calculate-alpha-shape-neighborhoods","title":"Calculate Alpha Shape Neighborhoods\u00b6","text":""},{"location":"examples/brief_notebooks/Pre-process_Xenium_V1_human_Pancreas_FFPE_outs/","title":"Pre-process_Xenium_V1_human_Pancreas_FFPE_outs","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n%env ANYWIDGET_HMR=1\n</pre> %load_ext autoreload %autoreload 2 %env ANYWIDGET_HMR=1 <pre>env: ANYWIDGET_HMR=1\n</pre> In\u00a0[2]: Copied! <pre>import numpy as np\nimport pandas as pd\n\n# macOS requirement\nimport os\nos.environ['DYLD_LIBRARY_PATH'] = '/opt/homebrew/lib:' + os.environ.get('DYLD_LIBRARY_PATH', '')\n\nimport celldega as dega\n\nimport tifffile\nimport zarr\n\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_hex\n\nimport geopandas as gpd\nimport shapely\n\nimport tarfile\ndega.__version__\n</pre> import numpy as np import pandas as pd  # macOS requirement import os os.environ['DYLD_LIBRARY_PATH'] = '/opt/homebrew/lib:' + os.environ.get('DYLD_LIBRARY_PATH', '')  import celldega as dega  import tifffile import zarr  import matplotlib.pyplot as plt from matplotlib.colors import to_hex  import geopandas as gpd import shapely  import tarfile dega.__version__ <pre>merged in latest changes\n</pre> Out[2]: <pre>'0.5.4'</pre> In\u00a0[3]: Copied! <pre>ls ../data/xenium_data/Xenium_V1_human_Pancreas_FFPE_outs/\n</pre> ls ../data/xenium_data/Xenium_V1_human_Pancreas_FFPE_outs/ <pre>ls: ../data/xenium_data/Xenium_V1_human_Pancreas_FFPE_outs/: No such file or directory\n</pre> In\u00a0[4]: Copied! <pre>ls ../data/xenium_landscapes/\n</pre> ls ../data/xenium_landscapes/ <pre>Landscape_Xenium_V1_human_Pancreas_FFPE_outs_backup/\nLandscape_Xenium_V1_human_Pancreas_FFPE_outs_png/\nLandscape_Xenium_V1_human_Pancreas_FFPE_outs_webp/\nXenium_Prime_Human_Lymph_Node_Reactive_FFPE_outs/\nXenium_Prime_Human_Lymph_Node_Reactive_FFPE_outs_landscape_files/\nXenium_Prime_Human_Prostate_FFPE_outs/\nXenium_Prime_Human_Skin_FFPE_outs_original/\nXenium_V1_hBoneMarrow_nondiseased_section_outs_landscape_files/\nXenium_V1_hBoneMarrow_nondiseased_section_outs_unscaled/\n</pre> In\u00a0[5]: Copied! <pre>dataset_name = 'Xenium_V1_human_Pancreas_FFPE_outs'\n</pre> dataset_name = 'Xenium_V1_human_Pancreas_FFPE_outs' In\u00a0[6]: Copied! <pre>base_path = 'data/xenium_data/' + dataset_name + '/'\n</pre> base_path = 'data/xenium_data/' + dataset_name + '/' In\u00a0[7]: Copied! <pre>path_landscape_files = 'data/xenium_landscapes/' + dataset_name + '_sparse/'\n</pre> path_landscape_files = 'data/xenium_landscapes/' + dataset_name + '_sparse/' In\u00a0[8]: Copied! <pre>base_path\n</pre> base_path Out[8]: <pre>'data/xenium_data/Xenium_V1_human_Pancreas_FFPE_outs/'</pre> In\u00a0[9]: Copied! <pre>path_landscape_files\n</pre> path_landscape_files Out[9]: <pre>'data/xenium_landscapes/Xenium_V1_human_Pancreas_FFPE_outs_sparse/'</pre> In\u00a0[10]: Copied! <pre>if not os.path.exists(path_landscape_files):\n    os.mkdir(path_landscape_files)\n</pre> if not os.path.exists(path_landscape_files):     os.mkdir(path_landscape_files) In\u00a0[11]: Copied! <pre># # Path to the tar.gz file you want to decompress\n# tar_file_path = base_path + 'cell_feature_matrix.tar.gz'\n# # Path to the directory where you want to extract the contents\n# output_directory = path_landscape_files\n\n# # Open the tar.gz file\n# with tarfile.open(tar_file_path, \"r:gz\") as tar:\n#     # Extract all contents to the specified directory\n#     tar.extractall(path=output_directory)\n\n# print(f\"File {tar_file_path} has been decompressed to {output_directory}\")\n</pre> # # Path to the tar.gz file you want to decompress # tar_file_path = base_path + 'cell_feature_matrix.tar.gz' # # Path to the directory where you want to extract the contents # output_directory = path_landscape_files  # # Open the tar.gz file # with tarfile.open(tar_file_path, \"r:gz\") as tar: #     # Extract all contents to the specified directory #     tar.extractall(path=output_directory)  # print(f\"File {tar_file_path} has been decompressed to {output_directory}\")  In\u00a0[12]: Copied! <pre># # Path to the tar.gz file you want to decompress\n# tar_file_path = base_path + 'analysis.tar.gz'\n# # Path to the directory where you want to extract the contents\n# output_directory = path_landscape_files\n\n# # Open the tar.gz file\n# with tarfile.open(tar_file_path, \"r:gz\") as tar:\n#     # Extract all contents to the specified directory\n#     tar.extractall(path=output_directory)\n\n# print(f\"File {tar_file_path} has been decompressed to {output_directory}\")\n</pre> # # Path to the tar.gz file you want to decompress # tar_file_path = base_path + 'analysis.tar.gz' # # Path to the directory where you want to extract the contents # output_directory = path_landscape_files  # # Open the tar.gz file # with tarfile.open(tar_file_path, \"r:gz\") as tar: #     # Extract all contents to the specified directory #     tar.extractall(path=output_directory)  # print(f\"File {tar_file_path} has been decompressed to {output_directory}\")  In\u00a0[13]: Copied! <pre>cbg = dega.pre.read_cbg_mtx(base_path + 'cell_feature_matrix/')\ncbg\n</pre> cbg = dega.pre.read_cbg_mtx(base_path + 'cell_feature_matrix/') cbg <pre>Reading mtx file from  data/xenium_data/Xenium_V1_human_Pancreas_FFPE_outs/cell_feature_matrix/\n</pre> Out[13]: __index_level_0__ ABCC11 ACE2 ACKR1 ACTA2 ACTG2 ADAM28 ADAMTS1 ADGRE1 ADGRL4 ADH1C ... UnassignedCodeword_0490 UnassignedCodeword_0491 UnassignedCodeword_0492 UnassignedCodeword_0493 UnassignedCodeword_0494 UnassignedCodeword_0495 UnassignedCodeword_0496 UnassignedCodeword_0497 UnassignedCodeword_0498 UnassignedCodeword_0499 0 aaaadnje-1 0 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 0 aaacalai-1 0 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 0 aaacjgil-1 0 0 0 0 1 1 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 0 aaacpcil-1 0 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 0 aaadhocp-1 0 0 0 1 2 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 0 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... oiloppgp-1 0 0 0 0 1 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 0 oilpccne-1 0 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 0 oimacfoj-1 0 0 0 0 0 0 1 0 0 0 ... 0 0 0 0 0 0 0 0 0 0 oimaiaae-1 0 0 1 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 0 oimajkkk-1 0 0 0 0 0 0 1 0 0 0 ... 0 0 0 0 0 0 0 0 0 0 <p>140702 rows \u00d7 541 columns</p> In\u00a0[14]: Copied! <pre>meta_gene_exp = dega.pre.calc_meta_gene_data(cbg)\n</pre> meta_gene_exp = dega.pre.calc_meta_gene_data(cbg) <pre>calculating mean expression from sparse float data\ncalculating variance by looping over rows\n</pre> In\u00a0[15]: Copied! <pre>path_cbg = base_path + 'cell_feature_matrix/'\npath_output = path_landscape_files + 'meta_gene.parquet'\ndega.pre.make_meta_gene('Xenium', path_cbg, path_output)\n</pre> path_cbg = base_path + 'cell_feature_matrix/' path_output = path_landscape_files + 'meta_gene.parquet' dega.pre.make_meta_gene('Xenium', path_cbg, path_output) <pre>Reading mtx file from  data/xenium_data/Xenium_V1_human_Pancreas_FFPE_outs/cell_feature_matrix/\ncalculating mean expression from sparse float data\ncalculating variance by looping over rows\n</pre> In\u00a0[16]: Copied! <pre>dega.pre.save_cbg_gene_parquets(path_landscape_files, cbg, verbose=True)\n</pre> dega.pre.save_cbg_gene_parquets(path_landscape_files, cbg, verbose=True) <pre>Processing gene 0: ABCC11\nProcessing gene 100: CLECL1\nProcessing gene 200: IL1RL1\nProcessing gene 300: RGS16\nProcessing gene 400: NegControlCodeword_0503\nProcessing gene 500: UnassignedCodeword_0459\n</pre> In\u00a0[17]: Copied! <pre>import tifffile\n\n# Path to your OME-TIFF file\nfile_path = base_path + 'morphology_focus/morphology_focus_0000.ome.tif'\n\n# Open the OME-TIFF file and read the image data\nwith tifffile.TiffFile(file_path) as tif:\n    series = tif.series[0]  # Assuming you are interested in the first series\n    image_data = series.asarray()\n</pre> import tifffile  # Path to your OME-TIFF file file_path = base_path + 'morphology_focus/morphology_focus_0000.ome.tif'  # Open the OME-TIFF file and read the image data with tifffile.TiffFile(file_path) as tif:     series = tif.series[0]  # Assuming you are interested in the first series     image_data = series.asarray()  <pre>&lt;tifffile.TiffFile 'morphology_focus_0000.ome.tif'&gt; OME series cannot read multi-file pyramids\n</pre> In\u00a0[18]: Copied! <pre>image_data.shape\n</pre> image_data.shape Out[18]: <pre>(4, 13770, 34155)</pre> In\u00a0[19]: Copied! <pre># from skimage.io import imread\n</pre> # from skimage.io import imread In\u00a0[20]: Copied! <pre># image_scale = 1\n# # file_path = f\"{data_dir}/morphology_focus_0000.ome.tif\"\n# file_path = base_path + 'morphology_focus/morphology_focus_0000.ome.tif'\n\n# img = imread(file_path)[...,0]\n\n# img_8bit = dega.pre.check_and_convert_16_to_8_bit(img)\n</pre> # image_scale = 1 # # file_path = f\"{data_dir}/morphology_focus_0000.ome.tif\" # file_path = base_path + 'morphology_focus/morphology_focus_0000.ome.tif'  # img = imread(file_path)[...,0]  # img_8bit = dega.pre.check_and_convert_16_to_8_bit(img) <p>how can this be adapted to additional channels?</p> In\u00a0[21]: Copied! <pre># img = imread(file_path)[...,0]\n# img_8bit = dega.pre.check_and_convert_16_to_8_bit(img)\n# dega.pre.make_deepzoom_pyramid(\n#     img_8bit, \n#     f\"{path_landscape_files}/pyramid_images\", \n#     'dapi', \n#     clahe_tile_size=32, \n#     clahe_contrast_limit=60, \n#     suffix=\".webp[Q=100]\"\n# )\n</pre> # img = imread(file_path)[...,0] # img_8bit = dega.pre.check_and_convert_16_to_8_bit(img) # dega.pre.make_deepzoom_pyramid( #     img_8bit,  #     f\"{path_landscape_files}/pyramid_images\",  #     'dapi',  #     clahe_tile_size=32,  #     clahe_contrast_limit=60,  #     suffix=\".webp[Q=100]\" # ) In\u00a0[22]: Copied! <pre># img = imread(file_path)[...,1]\n# img_8bit = dega.pre.check_and_convert_16_to_8_bit(img)\n# dega.pre.make_deepzoom_pyramid(\n#     img_8bit, \n#     f\"{path_landscape_files}/pyramid_images\", \n#     'bound', \n#     clahe_tile_size=32, \n#     clahe_contrast_limit=60, \n#     suffix=\".webp[Q=100]\"\n# )\n</pre> # img = imread(file_path)[...,1] # img_8bit = dega.pre.check_and_convert_16_to_8_bit(img) # dega.pre.make_deepzoom_pyramid( #     img_8bit,  #     f\"{path_landscape_files}/pyramid_images\",  #     'bound',  #     clahe_tile_size=32,  #     clahe_contrast_limit=60,  #     suffix=\".webp[Q=100]\" # ) In\u00a0[23]: Copied! <pre># img = imread(file_path)[...,2]\n# img_8bit = dega.pre.check_and_convert_16_to_8_bit(img)\n# dega.pre.make_deepzoom_pyramid(\n#     img_8bit, \n#     f\"{path_landscape_files}/pyramid_images\", \n#     'rna', \n#     clahe_tile_size=32, \n#     clahe_contrast_limit=60, \n#     suffix=\".webp[Q=100]\"\n# )\n</pre> # img = imread(file_path)[...,2] # img_8bit = dega.pre.check_and_convert_16_to_8_bit(img) # dega.pre.make_deepzoom_pyramid( #     img_8bit,  #     f\"{path_landscape_files}/pyramid_images\",  #     'rna',  #     clahe_tile_size=32,  #     clahe_contrast_limit=60,  #     suffix=\".webp[Q=100]\" # ) In\u00a0[24]: Copied! <pre># img = imread(file_path)[...,3]\n# img_8bit = dega.pre.check_and_convert_16_to_8_bit(img)\n# dega.pre.make_deepzoom_pyramid(\n#     img_8bit, \n#     f\"{path_landscape_files}/pyramid_images\", \n#     'prot', \n#     clahe_tile_size=32, \n#     clahe_contrast_limit=60, \n#     suffix=\".webp[Q=100]\"\n# )\n</pre> # img = imread(file_path)[...,3] # img_8bit = dega.pre.check_and_convert_16_to_8_bit(img) # dega.pre.make_deepzoom_pyramid( #     img_8bit,  #     f\"{path_landscape_files}/pyramid_images\",  #     'prot',  #     clahe_tile_size=32,  #     clahe_contrast_limit=60,  #     suffix=\".webp[Q=100]\" # ) In\u00a0[25]: Copied! <pre>image_scale = 1.0\n</pre> image_scale = 1.0 In\u00a0[26]: Copied! <pre>suffix = '.webp[Q=100]'\n</pre> suffix = '.webp[Q=100]' In\u00a0[27]: Copied! <pre>image_data_scaled = image_data[0,:,:] * 2\n\n# Save the image data to a regular TIFF file without compression\ntifffile.imwrite(path_landscape_files + 'output_regular.tif', image_data_scaled, compression=None)\nimage_ds = dega.pre.reduce_image_size(path_landscape_files + 'output_regular.tif', image_scale, path_landscape_files)\nimage_png = dega.pre.convert_to_png(image_ds)\ndega.pre.make_deepzoom_pyramid(image_png, path_landscape_files + 'pyramid_images/', 'dapi', suffix=suffix)\n</pre> image_data_scaled = image_data[0,:,:] * 2  # Save the image data to a regular TIFF file without compression tifffile.imwrite(path_landscape_files + 'output_regular.tif', image_data_scaled, compression=None) image_ds = dega.pre.reduce_image_size(path_landscape_files + 'output_regular.tif', image_scale, path_landscape_files) image_png = dega.pre.convert_to_png(image_ds) dega.pre.make_deepzoom_pyramid(image_png, path_landscape_files + 'pyramid_images/', 'dapi', suffix=suffix) In\u00a0[28]: Copied! <pre>image_data_scaled = image_data[1,:,:] * 2\n\n# Save the image data to a regular TIFF file without compression\ntifffile.imwrite(path_landscape_files + 'output_regular.tif', image_data_scaled, compression=None)\nimage_ds = dega.pre.reduce_image_size(path_landscape_files + 'output_regular.tif', image_scale, path_landscape_files)\nimage_png = dega.pre.convert_to_png(image_ds)\ndega.pre.make_deepzoom_pyramid(image_png, path_landscape_files + 'pyramid_images/', 'bound', suffix=suffix)\n</pre> image_data_scaled = image_data[1,:,:] * 2  # Save the image data to a regular TIFF file without compression tifffile.imwrite(path_landscape_files + 'output_regular.tif', image_data_scaled, compression=None) image_ds = dega.pre.reduce_image_size(path_landscape_files + 'output_regular.tif', image_scale, path_landscape_files) image_png = dega.pre.convert_to_png(image_ds) dega.pre.make_deepzoom_pyramid(image_png, path_landscape_files + 'pyramid_images/', 'bound', suffix=suffix) In\u00a0[29]: Copied! <pre>image_data_scaled = image_data[2,:,:] * 2\n\n# Save the image data to a regular TIFF file without compression\ntifffile.imwrite(path_landscape_files + 'output_regular.tif', image_data_scaled, compression=None)\nimage_ds = dega.pre.reduce_image_size(path_landscape_files + 'output_regular.tif', image_scale, path_landscape_files)\nimage_png = dega.pre.convert_to_png(image_ds)\ndega.pre.make_deepzoom_pyramid(image_png, path_landscape_files + 'pyramid_images/', 'rna', suffix=suffix)\n</pre> image_data_scaled = image_data[2,:,:] * 2  # Save the image data to a regular TIFF file without compression tifffile.imwrite(path_landscape_files + 'output_regular.tif', image_data_scaled, compression=None) image_ds = dega.pre.reduce_image_size(path_landscape_files + 'output_regular.tif', image_scale, path_landscape_files) image_png = dega.pre.convert_to_png(image_ds) dega.pre.make_deepzoom_pyramid(image_png, path_landscape_files + 'pyramid_images/', 'rna', suffix=suffix) In\u00a0[30]: Copied! <pre>image_data_scaled = image_data[3,:,:] * 2\n\n# Save the image data to a regular TIFF file without compression\ntifffile.imwrite(path_landscape_files + 'output_regular.tif', image_data_scaled, compression=None)\nimage_ds = dega.pre.reduce_image_size(path_landscape_files + 'output_regular.tif', image_scale, path_landscape_files)\nimage_png = dega.pre.convert_to_png(image_ds)\ndega.pre.make_deepzoom_pyramid(image_png, path_landscape_files + 'pyramid_images/', 'prot', suffix=suffix)\n</pre> image_data_scaled = image_data[3,:,:] * 2  # Save the image data to a regular TIFF file without compression tifffile.imwrite(path_landscape_files + 'output_regular.tif', image_data_scaled, compression=None) image_ds = dega.pre.reduce_image_size(path_landscape_files + 'output_regular.tif', image_scale, path_landscape_files) image_png = dega.pre.convert_to_png(image_ds) dega.pre.make_deepzoom_pyramid(image_png, path_landscape_files + 'pyramid_images/', 'prot', suffix=suffix) In\u00a0[31]: Copied! <pre># Function to open a Zarr file\ndef open_zarr(path: str) -&gt; zarr.Group:\n    store = (zarr.ZipStore(path, mode=\"r\")\n    if path.endswith(\".zip\")\n    else zarr.DirectoryStore(path)\n    )\n    return zarr.group(store=store)\n\n# For example, use the above function to open the cells Zarr file, which contains segmentation mask Zarr arrays\nroot = open_zarr(base_path + \"cells.zarr.zip\")\n\n# # Look at group array info and structure\n# root.info\n# root.tree() # shows structure, array dimensions, data types\n</pre> # Function to open a Zarr file def open_zarr(path: str) -&gt; zarr.Group:     store = (zarr.ZipStore(path, mode=\"r\")     if path.endswith(\".zip\")     else zarr.DirectoryStore(path)     )     return zarr.group(store=store)  # For example, use the above function to open the cells Zarr file, which contains segmentation mask Zarr arrays root = open_zarr(base_path + \"cells.zarr.zip\")  # # Look at group array info and structure # root.info # root.tree() # shows structure, array dimensions, data types  In\u00a0[32]: Copied! <pre>transformation_matrix = root['masks']['homogeneous_transform'][:]\ntransformation_matrix\n</pre> transformation_matrix = root['masks']['homogeneous_transform'][:] transformation_matrix Out[32]: <pre>array([[4.705882, 0.      , 0.      , 0.      ],\n       [0.      , 4.705882, 0.      , 0.      ],\n       [0.      , 0.      , 1.      , 0.      ],\n       [0.      , 0.      , 0.      , 1.      ]], dtype=float32)</pre> In\u00a0[33]: Copied! <pre>pd.DataFrame(transformation_matrix[:3,:3]).to_csv(\n    path_landscape_files + 'xenium_transform.csv', \n    sep=' ', \n    header=False, \n    index=False\n)\n</pre> pd.DataFrame(transformation_matrix[:3,:3]).to_csv(     path_landscape_files + 'xenium_transform.csv',      sep=' ',      header=False,      index=False ) In\u00a0[34]: Copied! <pre>path_transformation_matrix = path_landscape_files + 'xenium_transform.csv'\npath_meta_cell_micron = base_path + 'cells.csv.gz'\npath_meta_cell_image = path_landscape_files + 'cell_metadata.parquet'\n</pre> path_transformation_matrix = path_landscape_files + 'xenium_transform.csv' path_meta_cell_micron = base_path + 'cells.csv.gz' path_meta_cell_image = path_landscape_files + 'cell_metadata.parquet' In\u00a0[35]: Copied! <pre>default_clustering = pd.read_csv(base_path + 'analysis/clustering/gene_expression_graphclust/clusters.csv', index_col=0)\ndefault_clustering\n</pre> default_clustering = pd.read_csv(base_path + 'analysis/clustering/gene_expression_graphclust/clusters.csv', index_col=0) default_clustering Out[35]: Cluster Barcode aaaadnje-1 15 aaacalai-1 9 aaacjgil-1 15 aaacpcil-1 13 aaadhocp-1 18 ... ... oiloppgp-1 10 oilpccne-1 6 oimacfoj-1 10 oimaiaae-1 11 oimajkkk-1 23 <p>140194 rows \u00d7 1 columns</p> In\u00a0[36]: Copied! <pre># do not including clustering information in default cell metadata\ndega.pre.make_meta_cell_image_coord(\n    'Xenium', \n    path_transformation_matrix, \n    path_meta_cell_micron, \n    path_meta_cell_image, \n    image_scale=image_scale\n)\n</pre> # do not including clustering information in default cell metadata dega.pre.make_meta_cell_image_coord(     'Xenium',      path_transformation_matrix,      path_meta_cell_micron,      path_meta_cell_image,      image_scale=image_scale ) In\u00a0[37]: Copied! <pre>if not os.path.exists(path_landscape_files + 'cell_clusters/'):\n    os.mkdir(path_landscape_files + 'cell_clusters/')\n</pre> if not os.path.exists(path_landscape_files + 'cell_clusters/'):     os.mkdir(path_landscape_files + 'cell_clusters/') In\u00a0[38]: Copied! <pre>default_clustering = pd.DataFrame(default_clustering.values, index=default_clustering.index.tolist(), columns=['cluster'])\ndefault_clustering.head()\n</pre> default_clustering = pd.DataFrame(default_clustering.values, index=default_clustering.index.tolist(), columns=['cluster']) default_clustering.head() Out[38]: cluster aaaadnje-1 15 aaacalai-1 9 aaacjgil-1 15 aaacpcil-1 13 aaadhocp-1 18 In\u00a0[39]: Copied! <pre>default_clustering_ini = pd.DataFrame(default_clustering.values, index=default_clustering.index.tolist(), columns=['cluster'])\ndefault_clustering_ini.head()\n</pre> default_clustering_ini = pd.DataFrame(default_clustering.values, index=default_clustering.index.tolist(), columns=['cluster']) default_clustering_ini.head() Out[39]: cluster aaaadnje-1 15 aaacalai-1 9 aaacjgil-1 15 aaacpcil-1 13 aaadhocp-1 18 In\u00a0[40]: Copied! <pre>meta_cell = pd.read_parquet(path_landscape_files + 'cell_metadata.parquet')\nmeta_cell.shape\n</pre> meta_cell = pd.read_parquet(path_landscape_files + 'cell_metadata.parquet') meta_cell.shape Out[40]: <pre>(140702, 2)</pre> In\u00a0[41]: Copied! <pre>default_clustering_ini['cluster'] = default_clustering_ini['cluster'].astype('string')\n</pre> default_clustering_ini['cluster'] = default_clustering_ini['cluster'].astype('string') In\u00a0[42]: Copied! <pre>default_clustering = pd.DataFrame(index=meta_cell.index.tolist())\n\ndefault_clustering.loc[default_clustering_ini.index.tolist(), 'cluster'] = default_clustering_ini['cluster']\n</pre> default_clustering = pd.DataFrame(index=meta_cell.index.tolist())  default_clustering.loc[default_clustering_ini.index.tolist(), 'cluster'] = default_clustering_ini['cluster'] In\u00a0[43]: Copied! <pre>default_clustering.to_parquet(path_landscape_files + 'cell_clusters/cluster.parquet')\n</pre> default_clustering.to_parquet(path_landscape_files + 'cell_clusters/cluster.parquet') In\u00a0[44]: Copied! <pre>df_meta = pd.read_csv(base_path + 'analysis/clustering/gene_expression_graphclust/clusters.csv', index_col=0)\ndf_meta['Cluster'] = df_meta['Cluster'].astype('string')\ndf_meta.columns = ['cluster']\n</pre> df_meta = pd.read_csv(base_path + 'analysis/clustering/gene_expression_graphclust/clusters.csv', index_col=0) df_meta['Cluster'] = df_meta['Cluster'].astype('string') df_meta.columns = ['cluster'] In\u00a0[45]: Copied! <pre># dega.pre.make_meta_cell_image_coord(\n#     'Xenium', \n#     path_transformation_matrix, \n#     path_meta_cell_micron, \n#     path_meta_cell_image, \n#     df_meta=df_meta\n# )\n</pre> # dega.pre.make_meta_cell_image_coord( #     'Xenium',  #     path_transformation_matrix,  #     path_meta_cell_micron,  #     path_meta_cell_image,  #     df_meta=df_meta # ) In\u00a0[46]: Copied! <pre>ser_counts = default_clustering['cluster'].value_counts()\nclusters = ser_counts.index.tolist()\n</pre> ser_counts = default_clustering['cluster'].value_counts() clusters = ser_counts.index.tolist() In\u00a0[47]: Copied! <pre># Get all categorical color palettes from Matplotlib and flatten them into a single list of colors\npalettes = [plt.get_cmap(name).colors for name in plt.colormaps() if \"tab\" in name]\nflat_colors = [color for palette in palettes for color in palette]\n\n# Convert RGB tuples to hex codes\nflat_colors_hex = [to_hex(color) for color in flat_colors]\n\n# Use modular arithmetic to assign a color to each gene, white for genes with \"Blank\"\ncolors = [\n    flat_colors_hex[i % len(flat_colors_hex)] if \"Blank\" not in cluster else \"#FFFFFF\"\n    for i, cluster in enumerate(clusters)\n]\n\n# Create a DataFrame with genes and their assigned colors\nser_color = pd.Series(colors, index=clusters, name='color')\n\nmeta_cluster = pd.DataFrame(ser_color)\n\nmeta_cluster['count'] = ser_counts\n\nmeta_cluster.to_parquet(path_landscape_files + 'cell_clusters/meta_cluster.parquet')\n</pre> # Get all categorical color palettes from Matplotlib and flatten them into a single list of colors palettes = [plt.get_cmap(name).colors for name in plt.colormaps() if \"tab\" in name] flat_colors = [color for palette in palettes for color in palette]  # Convert RGB tuples to hex codes flat_colors_hex = [to_hex(color) for color in flat_colors]  # Use modular arithmetic to assign a color to each gene, white for genes with \"Blank\" colors = [     flat_colors_hex[i % len(flat_colors_hex)] if \"Blank\" not in cluster else \"#FFFFFF\"     for i, cluster in enumerate(clusters) ]  # Create a DataFrame with genes and their assigned colors ser_color = pd.Series(colors, index=clusters, name='color')  meta_cluster = pd.DataFrame(ser_color)  meta_cluster['count'] = ser_counts  meta_cluster.to_parquet(path_landscape_files + 'cell_clusters/meta_cluster.parquet') In\u00a0[48]: Copied! <pre>tile_size = 200\n</pre> tile_size = 200 In\u00a0[49]: Copied! <pre>%%time \ntechnology = 'Xenium'\npath_trx = base_path + 'transcripts.parquet'\npath_trx_tiles = path_landscape_files + 'transcript_tiles'\ntile_bounds = dega.pre.make_trx_tiles(\n    'Xenium', \n    path_trx, \n    path_transformation_matrix, \n    path_trx_tiles,\n    # tile_size=tile_size,\n    # coarse_tile_size=tile_size * 10,\n    tile_size=tile_size,    \n    image_scale=image_scale\n    # verbose=True\n)\n</pre> %%time  technology = 'Xenium' path_trx = base_path + 'transcripts.parquet' path_trx_tiles = path_landscape_files + 'transcript_tiles' tile_bounds = dega.pre.make_trx_tiles(     'Xenium',      path_trx,      path_transformation_matrix,      path_trx_tiles,     # tile_size=tile_size,     # coarse_tile_size=tile_size * 10,     tile_size=tile_size,         image_scale=image_scale     # verbose=True ) <pre>Processing chunks: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 9/9 [00:00&lt;00:00, 14.69it/s]\nProcessing coarse tiles: 126tile [00:17,  7.15tile/s]</pre> <pre>CPU times: user 30.2 s, sys: 27 s, total: 57.1 s\nWall time: 18.8 s\n</pre> <pre>\n</pre> In\u00a0[50]: Copied! <pre>%%time\npath_cell_boundaries = base_path + 'cell_boundaries.parquet'\npath_output = path_landscape_files + 'cell_segmentation'\ndega.pre.make_cell_boundary_tiles(\n    'Xenium',\n    path_cell_boundaries, \n    path_meta_cell_micron, \n    path_transformation_matrix, \n    path_output,\n    #coarse_tile_size=tile_size * 10,\n    tile_size=tile_size,\n    tile_bounds=tile_bounds,\n    image_scale=image_scale\n)\n</pre> %%time path_cell_boundaries = base_path + 'cell_boundaries.parquet' path_output = path_landscape_files + 'cell_segmentation' dega.pre.make_cell_boundary_tiles(     'Xenium',     path_cell_boundaries,      path_meta_cell_micron,      path_transformation_matrix,      path_output,     #coarse_tile_size=tile_size * 10,     tile_size=tile_size,     tile_bounds=tile_bounds,     image_scale=image_scale ) <pre>Processing coarse tiles: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 9/9 [00:13&lt;00:00,  1.52s/it]\n</pre> <pre>CPU times: user 23.1 s, sys: 7.1 s, total: 30.3 s\nWall time: 24.4 s\n</pre> In\u00a0[51]: Copied! <pre>path_cbg = base_path + 'cell_feature_matrix/'\npath_output = path_landscape_files + 'gene_metadata.parquet'\ndega.pre.make_meta_gene('Xenium', path_cbg, path_output)\n</pre> path_cbg = base_path + 'cell_feature_matrix/' path_output = path_landscape_files + 'gene_metadata.parquet' dega.pre.make_meta_gene('Xenium', path_cbg, path_output) <pre>Reading mtx file from  data/xenium_data/Xenium_V1_human_Pancreas_FFPE_outs/cell_feature_matrix/\ncalculating mean expression from sparse float data\ncalculating variance by looping over rows\n</pre> In\u00a0[52]: Copied! <pre># Example usage:\npath_image_pyramid = path_landscape_files + 'pyramid_images/dapi_files/'  # Change this to your actual directory path\nmax_pyramid_zoom = dega.pre.get_max_zoom_level(path_image_pyramid)\n\nprint(max_pyramid_zoom)\n</pre> # Example usage: path_image_pyramid = path_landscape_files + 'pyramid_images/dapi_files/'  # Change this to your actual directory path max_pyramid_zoom = dega.pre.get_max_zoom_level(path_image_pyramid)  print(max_pyramid_zoom) <pre>16\n</pre> In\u00a0[53]: Copied! <pre>usecols = ['cell_id', 'x_centroid', 'y_centroid']\nmeta_cell = pd.read_csv(base_path + 'cells.csv.gz', index_col=0, usecols=usecols)\nmeta_cell.columns = ['center_x', 'center_y']\nmeta_cell\n</pre> usecols = ['cell_id', 'x_centroid', 'y_centroid'] meta_cell = pd.read_csv(base_path + 'cells.csv.gz', index_col=0, usecols=usecols) meta_cell.columns = ['center_x', 'center_y'] meta_cell Out[53]: center_x center_y cell_id aaaadnje-1 446.326691 1701.357300 aaacalai-1 441.307831 1735.877930 aaacjgil-1 466.053192 1712.259766 aaacpcil-1 430.858093 1707.464600 aaadhocp-1 476.111145 1711.089355 ... ... ... oiloppgp-1 6082.675781 555.142883 oilpccne-1 6106.899414 494.951843 oimacfoj-1 6080.991211 626.742126 oimaiaae-1 6030.594727 536.503418 oimajkkk-1 6022.637207 573.784302 <p>140702 rows \u00d7 2 columns</p> In\u00a0[54]: Copied! <pre>df_meta = pd.read_csv(base_path + 'analysis/clustering/gene_expression_graphclust/clusters.csv', index_col=0)\ndf_meta['Cluster'] = df_meta['Cluster'].astype('string')\ndf_meta.columns = ['cluster']\n</pre> df_meta = pd.read_csv(base_path + 'analysis/clustering/gene_expression_graphclust/clusters.csv', index_col=0) df_meta['Cluster'] = df_meta['Cluster'].astype('string') df_meta.columns = ['cluster'] In\u00a0[55]: Copied! <pre>meta_cell['cluster'] = df_meta['cluster']\n</pre> meta_cell['cluster'] = df_meta['cluster'] In\u00a0[56]: Copied! <pre>list_ser = []\nfor inst_cat in meta_cell['cluster'].unique().tolist():\n    if inst_cat is not None:\n        inst_cells = meta_cell[meta_cell['cluster'] == inst_cat].index.tolist()\n        # print(inst_cat, len(inst_cells))\n\n        inst_ser = cbg.loc[inst_cells].sum()/len(inst_cells)\n        inst_ser.name = inst_cat\n\n        list_ser.append(inst_ser)\n\ndf_sig = pd.concat(list_ser, axis=1)\n</pre> list_ser = [] for inst_cat in meta_cell['cluster'].unique().tolist():     if inst_cat is not None:         inst_cells = meta_cell[meta_cell['cluster'] == inst_cat].index.tolist()         # print(inst_cat, len(inst_cells))          inst_ser = cbg.loc[inst_cells].sum()/len(inst_cells)         inst_ser.name = inst_cat          list_ser.append(inst_ser)  df_sig = pd.concat(list_ser, axis=1)      In\u00a0[57]: Copied! <pre>df_sig = pd.concat(list_ser, axis=1)\n# handling weird behavior where there is a multiindex it appears\ndf_sig.columns = df_sig.columns.tolist()\ndf_sig.index = df_sig.index.tolist()\n</pre> df_sig = pd.concat(list_ser, axis=1) # handling weird behavior where there is a multiindex it appears df_sig.columns = df_sig.columns.tolist() df_sig.index = df_sig.index.tolist() In\u00a0[58]: Copied! <pre>keep_genes = df_sig.index.tolist()\nkeep_genes = [x for x in keep_genes if 'Unassigned' not in x]\nkeep_genes = [x for x in keep_genes if 'NegControl' not in x]\nkeep_genes = [x for x in keep_genes if 'DeprecatedCodeword' not in x]\nlen(keep_genes)\n\ndf_sig = df_sig.loc[keep_genes, clusters]\ndf_sig.shape\n</pre> keep_genes = df_sig.index.tolist() keep_genes = [x for x in keep_genes if 'Unassigned' not in x] keep_genes = [x for x in keep_genes if 'NegControl' not in x] keep_genes = [x for x in keep_genes if 'DeprecatedCodeword' not in x] len(keep_genes)  df_sig = df_sig.loc[keep_genes, clusters] df_sig.shape Out[58]: <pre>(377, 28)</pre> In\u00a0[59]: Copied! <pre>df_sig.sparse.to_dense().to_parquet(path_landscape_files + 'df_sig.parquet')\n</pre> df_sig.sparse.to_dense().to_parquet(path_landscape_files + 'df_sig.parquet') In\u00a0[60]: Copied! <pre>image_info =  [\n        {\n            \"name\": \"dapi\",\n            \"button_name\": \"DAPI\",\n            \"color\": [\n                0,\n                0,\n                255\n            ]\n        },\n        {\n            \"name\": \"bound\",\n            \"button_name\": \"BOUND\",\n            \"color\": [\n                0,\n                255,\n                0\n            ]\n        },\n        {\n            \"name\": \"rna\",\n            \"button_name\": \"RNA\",\n            \"color\": [\n                255,\n                0,\n                0\n            ]\n        },\n        {\n            \"name\": \"prot\",\n            \"button_name\": \"PROT\",\n            \"color\": [\n                255,\n                255,\n                255\n            ]\n        }\n    ]\n</pre> image_info =  [         {             \"name\": \"dapi\",             \"button_name\": \"DAPI\",             \"color\": [                 0,                 0,                 255             ]         },         {             \"name\": \"bound\",             \"button_name\": \"BOUND\",             \"color\": [                 0,                 255,                 0             ]         },         {             \"name\": \"rna\",             \"button_name\": \"RNA\",             \"color\": [                 255,                 0,                 0             ]         },         {             \"name\": \"prot\",             \"button_name\": \"PROT\",             \"color\": [                 255,                 255,                 255             ]         }     ] In\u00a0[61]: Copied! <pre>dega.pre.save_landscape_parameters(\n    'Xenium', \n    path_landscape_files,\n    'dapi_files',\n    tile_size=tile_size,\n    image_info=image_info,\n    image_format='.webp'\n)\n</pre> dega.pre.save_landscape_parameters(     'Xenium',      path_landscape_files,     'dapi_files',     tile_size=tile_size,     image_info=image_info,     image_format='.webp' ) <pre>data/xenium_landscapes/Xenium_V1_human_Pancreas_FFPE_outs_sparse//pyramid_images/dapi_files\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/brief_notebooks/Pre-process_Xenium_V1_human_Pancreas_FFPE_outs/#pre-process_xenium_v1_human_pancreas_ffpe_outs","title":"Pre-process_Xenium_V1_human_Pancreas_FFPE_outs\u00b6","text":""},{"location":"examples/brief_notebooks/Pre-process_Xenium_V1_human_Pancreas_FFPE_outs/#unzip-xenium-data","title":"Unzip Xenium Data\u00b6","text":""},{"location":"examples/brief_notebooks/Pre-process_Xenium_V1_human_Pancreas_FFPE_outs/#decompress-cell-feature-matrix-mtx-files","title":"Decompress Cell Feature Matrix MTX Files\u00b6","text":""},{"location":"examples/brief_notebooks/Pre-process_Xenium_V1_human_Pancreas_FFPE_outs/#decompress-xenium-analysis-files","title":"Decompress Xenium Analysis Files\u00b6","text":""},{"location":"examples/brief_notebooks/Pre-process_Xenium_V1_human_Pancreas_FFPE_outs/#cbg","title":"CBG\u00b6","text":""},{"location":"examples/brief_notebooks/Pre-process_Xenium_V1_human_Pancreas_FFPE_outs/#gene-metadata","title":"Gene Metadata\u00b6","text":""},{"location":"examples/brief_notebooks/Pre-process_Xenium_V1_human_Pancreas_FFPE_outs/#cell-by-gene-files","title":"Cell-by-gene Files\u00b6","text":""},{"location":"examples/brief_notebooks/Pre-process_Xenium_V1_human_Pancreas_FFPE_outs/#image-tiles","title":"Image Tiles\u00b6","text":""},{"location":"examples/brief_notebooks/Pre-process_Xenium_V1_human_Pancreas_FFPE_outs/#dapi","title":"DAPI\u00b6","text":""},{"location":"examples/brief_notebooks/Pre-process_Xenium_V1_human_Pancreas_FFPE_outs/#cell-metadata","title":"Cell Metadata\u00b6","text":""},{"location":"examples/brief_notebooks/Pre-process_Xenium_V1_human_Pancreas_FFPE_outs/#save-cell-metadata","title":"Save cell metadata\u00b6","text":""},{"location":"examples/brief_notebooks/Pre-process_Xenium_V1_human_Pancreas_FFPE_outs/#save-default-clustering-results","title":"Save default clustering results\u00b6","text":""},{"location":"examples/brief_notebooks/Pre-process_Xenium_V1_human_Pancreas_FFPE_outs/#cluster-colors","title":"Cluster Colors\u00b6","text":""},{"location":"examples/brief_notebooks/Pre-process_Xenium_V1_human_Pancreas_FFPE_outs/#transcripts","title":"Transcripts\u00b6","text":""},{"location":"examples/brief_notebooks/Pre-process_Xenium_V1_human_Pancreas_FFPE_outs/#cell-boundaries","title":"Cell Boundaries\u00b6","text":""},{"location":"examples/brief_notebooks/Pre-process_Xenium_V1_human_Pancreas_FFPE_outs/#gene-metadata","title":"Gene Metadata\u00b6","text":""},{"location":"examples/brief_notebooks/Pre-process_Xenium_V1_human_Pancreas_FFPE_outs/#max-zoom","title":"Max Zoom\u00b6","text":""},{"location":"examples/brief_notebooks/Pre-process_Xenium_V1_human_Pancreas_FFPE_outs/#cluster-gene-expression","title":"Cluster Gene Expression\u00b6","text":""},{"location":"examples/brief_notebooks/Pre-process_Xenium_V1_human_Pancreas_FFPE_outs/#save-landscape-parameters-json","title":"Save Landscape Parameters JSON\u00b6","text":""},{"location":"gallery/","title":"Celldega Gallery","text":"<p>This page includes links to visualizations that are made with the stand-alone Celldega JavaScript library.</p>"},{"location":"gallery/#imaging-spatial-transcriptomics","title":"Imaging Spatial Transcriptomics","text":""},{"location":"gallery/#xenium","title":"Xenium","text":"<ul> <li>Xenium Mouse Brain </li> <li>Xenium Human Skin Cancer </li> </ul>"},{"location":"gallery/#sequencing-spatial-transcriptomics","title":"Sequencing Spatial Transcriptomics","text":""},{"location":"gallery/#visium-hd","title":"Visium HD","text":""},{"location":"gallery/gallery_xenium/","title":"Celldega Xenium Gallery","text":""},{"location":"gallery/gallery_xenium/#xenium-prime-mouse-brain-coronal-ff","title":"Xenium Prime Mouse Brain Coronal FF","text":""},{"location":"gallery/gallery_xenium/#xenium-prime-human-skin-ffpe-outs","title":"Xenium Prime Human Skin FFPE outs","text":""},{"location":"gallery/gallery_xenium/#xenium-human-pancreas-ffpe","title":"Xenium Human Pancreas FFPE","text":""},{"location":"gallery/gallery_xenium/#bone-marrow","title":"Bone Marrow","text":""},{"location":"gallery/gallery_xenium_mouse_brain/","title":"Xenium Prime Mouse Brain Coronal FF","text":""},{"location":"gallery/gallery_xenium_multi/","title":"Xenium Multi Dataset","text":""},{"location":"gallery/gallery_xenium_multi/#xenium-prime-mouse-brain-coronal-ff","title":"Xenium Prime Mouse Brain Coronal FF","text":""},{"location":"gallery/gallery_xenium_multi/#xenium-prime-human-skin-ffpe-outs","title":"Xenium Prime Human Skin FFPE outs","text":""},{"location":"gallery/gallery_xenium_multi/#xenium-human-pancreas-ffpe","title":"Xenium Human Pancreas FFPE","text":""},{"location":"gallery/gallery_xenium_multi/#bone-marrow","title":"Bone Marrow","text":""},{"location":"gallery/gallery_xenium_skin_cancer/","title":"Xenium Prime Human Skin FFPE outs","text":""},{"location":"javascript/","title":"JavaScript API Overview","text":"<p>Celldega's visualization methods can be used as a stand-alone JavaScript library outside the context of a Jupyter notebook. This can be used to create showcase visualizations with publicly hosted data.</p>"},{"location":"javascript/api/","title":"Celldega JavaScript API Documentation","text":"<p>The JavaScript component of Celldega is used within the Jupyter Widgets framework to provide interactive visualization in the context of a Jupyter notebook but can also be used as a standalone JavaScript library.</p>"},{"location":"javascript/api/#landscape_ist-api-documentation","title":"<code>landscape_ist</code> API Documentation","text":"<p>The <code>landscape_ist</code> function initializes and renders an interactive spatial transcriptomics (IST) landscape visualization. This API is designed to work with Deck.gl and includes customizable visualization options, dynamic data updates, and UI interactions.</p>"},{"location":"javascript/api/#parameters","title":"Parameters","text":"<ul> <li><code>el</code> (<code>HTMLElement</code>): The root DOM element where the visualization is rendered.</li> <li><code>ini_model</code> (<code>Object</code>): The initial data model containing configuration and state.</li> <li><code>token</code> (<code>string</code>): Authentication token for accessing data.</li> <li><code>ini_x</code>, <code>ini_y</code>, <code>ini_z</code> (<code>number</code>): Initial spatial coordinates for the view.</li> <li><code>ini_zoom</code> (<code>number</code>): Initial zoom level for the visualization.</li> <li><code>base_url</code> (<code>string</code>): Base URL for accessing data files.</li> <li><code>dataset_name</code> (<code>string</code>, optional): Name of the dataset being visualized.</li> <li><code>trx_radius</code> (<code>number</code>, optional): Initial radius for transcript points. Default: <code>0.25</code>.</li> <li><code>width</code> (<code>number|string</code>, optional): Width of the visualization. Default: <code>100%</code>.</li> <li><code>height</code> (<code>number</code>, optional): Height of the visualization. Default: <code>800</code>.</li> <li><code>view_change_custom_callback</code> (<code>Function</code>, optional): Custom callback triggered on view changes.</li> </ul>"},{"location":"javascript/api/#public-api","title":"Public API","text":"<p>The <code>landscape_ist</code> function returns an object (<code>landscape</code>) with several methods for interacting with the visualization.</p>"},{"location":"javascript/api/#update_matrix_gene","title":"<code>update_matrix_gene</code>","text":"<p>Updates the visualization to highlight data for a specific gene.</p>"},{"location":"javascript/api/#parameters_1","title":"Parameters","text":"<ul> <li><code>inst_gene</code> (<code>string</code>): The gene to highlight.</li> </ul>"},{"location":"javascript/api/#behavior","title":"Behavior","text":"<ul> <li>Updates the transcript layer to show data for the specified gene.</li> <li>Scrolls the bar graph to bring the selected gene into view.</li> <li>Toggles visibility of image layers and controls based on the selected gene.</li> </ul>"},{"location":"javascript/api/#update_matrix_col","title":"<code>update_matrix_col</code>","text":"<p>Updates the visualization to highlight data for a specific column (e.g., cluster).</p>"},{"location":"javascript/api/#parameters_2","title":"Parameters","text":"<ul> <li><code>inst_col</code> (<code>string</code>): The column to highlight.</li> </ul>"},{"location":"javascript/api/#behavior_1","title":"Behavior","text":"<ul> <li>Highlights the bar graph corresponding to the selected column.</li> <li>Updates cell and path layers to reflect the selected column.</li> <li>Toggles visibility of layers based on the column selection.</li> </ul>"},{"location":"javascript/api/#update_matrix_dendro_col","title":"<code>update_matrix_dendro_col</code>","text":"<p>Updates the visualization based on a dendrogram selection of columns.</p>"},{"location":"javascript/api/#parameters_3","title":"Parameters","text":"<ul> <li><code>selected_cols</code> (<code>Array&lt;string&gt;</code>): The list of selected column names.</li> </ul>"},{"location":"javascript/api/#behavior_2","title":"Behavior","text":"<ul> <li>Highlights the selected columns in the bar graph.</li> <li>Updates layers to reflect the selection.</li> </ul>"},{"location":"javascript/api/#update_view_state","title":"<code>update_view_state</code>","text":"<p>Updates the view state of the Deck.gl visualization.</p>"},{"location":"javascript/api/#parameters_4","title":"Parameters","text":"<ul> <li><code>new_view_state</code> (<code>Object</code>): The new view state configuration.</li> <li><code>close_up</code> (<code>boolean</code>): Whether the view should zoom in closely.</li> <li><code>trx_layer</code> (<code>Object</code>): The transcript layer to update.</li> </ul>"},{"location":"javascript/api/#behavior_3","title":"Behavior","text":"<ul> <li>Adjusts the viewport and reconfigures layers based on the new view state.</li> </ul>"},{"location":"javascript/api/#update_layers","title":"<code>update_layers</code>","text":"<p>Updates all visualization layers.</p>"},{"location":"javascript/api/#behavior_4","title":"Behavior","text":"<ul> <li>Refreshes the Deck.gl layers with the current visualization state.</li> </ul>"},{"location":"javascript/api/#finalize","title":"<code>finalize</code>","text":"<p>Finalizes the Deck.gl instance and cleans up resources.</p>"},{"location":"javascript/api/#behavior_5","title":"Behavior","text":"<ul> <li>Disposes of all Deck.gl resources and event listeners to prevent memory leaks.</li> </ul>"},{"location":"javascript/api/#usage-example","title":"Usage Example","text":"<pre><code>\njavascript\nimport { landscape_ist } from 'path/to/landscape_ist';\n\nconst rootElement = document.getElementById('visualization-container');\nconst model = { /* Model containing visualization data */ };\n\nconst visualization = await landscape_ist(\n    rootElement,\n    model,\n    'example-token',\n    100,\n    200,\n    0,\n    -5,\n    'https://example.com/data',\n    'Example Dataset'\n);\n\n// Update the visualization with a specific gene.\nvisualization.update_matrix_gene('TP53');\n\n// Update the visualization with a specific column.\nvisualization.update_matrix_col('Cluster 1');\n\n// Finalize the visualization when done.\nvisualization.finalize();\n\n</code></pre>"},{"location":"javascript/api/#matrix_viz-api-documentation","title":"<code>matrix_viz</code> API Documentation","text":"<p>The <code>matrix_viz</code> function initializes and renders a matrix visualization. This API is built using approaches and code adaptations from the Clustergrammer-GL library, and it integrates tightly with Deck.gl to provide interactive and dynamic visualizations.</p>"},{"location":"javascript/api/#parameters_5","title":"Parameters","text":"<ul> <li><code>model</code> (<code>Object</code>): The model object containing configuration data for the visualization.</li> <li><code>el</code> (<code>HTMLElement</code>): The root DOM element where the visualization is rendered.</li> <li><code>network</code> (<code>Object</code>): The network object containing the matrix data to visualize.</li> <li><code>width</code> (<code>string|number</code>, optional): The width of the visualization. Default: <code>'800'</code>.</li> <li><code>height</code> (<code>string|number</code>, optional): The height of the visualization. Default: <code>'800'</code>.</li> <li><code>row_label_callback</code> (<code>Function</code>, optional): A callback function triggered on row label interactions.</li> <li><code>col_label_callback</code> (<code>Function</code>, optional): A callback function triggered on column label interactions.</li> <li><code>col_dendro_callback</code> (<code>Function</code>, optional): A callback function triggered on dendrogram column interactions.</li> </ul>"},{"location":"javascript/api/#internal-behavior","title":"Internal Behavior","text":"<p>The function performs the following setup: 1. Deck.gl Integration:    - Initializes a Deck.gl instance for the matrix visualization.    - Sets properties for interactivity, including tooltips, view state changes, and layer filtering.</p> <ol> <li>Matrix Data Setup:</li> <li>Parses and structures the matrix data from the <code>network</code> object.</li> <li> <p>Configures labels, categories, and dendrograms for both rows and columns.</p> </li> <li> <p>Layer Initialization:</p> </li> <li>Creates layers for:<ul> <li>Matrix cells.</li> <li>Row and column labels.</li> <li>Row and column categories.</li> <li>Row and column dendrograms.</li> </ul> </li> <li> <p>Attaches interactions (e.g., click events) to these layers.</p> </li> <li> <p>UI Setup:</p> </li> <li>Creates a container for the visualization and appends it to the root DOM element.</li> </ol>"},{"location":"javascript/api/#example-usage","title":"Example Usage","text":"<pre><code>import { matrix_viz } from 'path/to/matrix_viz';\n\nconst rootElement = document.getElementById('matrix-container');\nconst model = { /* Model containing visualization data */ };\nconst network = { /* Network object representing the matrix data */ };\n\n// Callback functions\nconst rowLabelCallback = (row) =&gt; {\n    console.log('Row label clicked:', row);\n};\n\nconst colLabelCallback = (col) =&gt; {\n    console.log('Column label clicked:', col);\n};\n\nconst colDendroCallback = (dendro) =&gt; {\n    console.log('Column dendrogram clicked:', dendro);\n};\n\n// Initialize the matrix visualization\nawait matrix_viz(\n    model,\n    rootElement,\n    network,\n    800,\n    800,\n    rowLabelCallback,\n    colLabelCallback,\n    colDendroCallback\n);\n</code></pre>"},{"location":"overview/","title":"Overview","text":"<p>The Celldega library is being developed to help researchers easily visualize and analyze high-dimensional spatial-omics data in the context of a notebook workflow. Initial development has been focused on spatial transcriptomics visualization.</p> <p>Celldega can be used as a Python library in a Jupyter notebook environment or as a stand-alone JavaScript library for creating visualizations.</p> <ul> <li>Getting Started</li> <li>Installation</li> <li>Usage</li> </ul>"},{"location":"overview/file_formats/","title":"Celldega File Formats","text":"<p>While there has been tremendous progress in developing standardized data formats and architectures for spatial-omics data, namely SpatialData and the related AnnData, these approaches currently lack support for interactive cloud-based visualization of large (&gt;100M transcripts) Spatial Transcriptomics (ST) data. Furthermore, all-in-one data format approaches preclude the development of compact visualization-specific data formats.</p> <p>The Celldega project addresses these challenges with the development of a new ST data format called LandscapeFiles, specifically built for cloud-based visualization. LandscapeFiles support Celldega's Landscape visualization method by leveraging compact image formats and cloud-native data formats to enable efficient storage and visualization of image (e.g., microscopy images) and vectorized data (e.g., transcript coordinates). This approach is highly scalable, enabling the visualization of very large ST datasets (&gt;400M transcripts), while remaining compact enough that the  LandscapeFiles for an entire Xenium dataset can be hosted in a public GitHub repository.</p>"},{"location":"overview/file_formats/#landscapefiles","title":"LandscapeFiles","text":"<p>LandscapeFiles are generated using the Celldega pre module (see example Google Colab notebook Celldega-Landscape-Pre-Process_Xenium-Pancreas-Dataset) and are used by Celldega's JavaScript front-end to interactively visualize ST data. Users have several options for hosting LandscapeFiles both locally on the cloud (e.g., Terra.bio buckets) or locally (e.g., running a local server to locally host LandscapeFiles).</p>"},{"location":"overview/file_formats/#ist-landscapefiles","title":"iST LandscapeFiles","text":"<p>The file structure for a Xenium Prime dataset's LandscapeFiles is shown below.</p> <pre><code>.\n\u251c\u2500\u2500 cbg\n\u251c\u2500\u2500 cell_clusters\n\u251c\u2500\u2500 cell_metadata.parquet\n\u251c\u2500\u2500 cell_segmentation\n\u251c\u2500\u2500 df_sig.parquet\n\u251c\u2500\u2500 landscape_parameters.json\n\u251c\u2500\u2500 meta_gene.parquet\n\u251c\u2500\u2500 pyramid_images\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 bound_files\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 dapi_files\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 prot_files\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 rna_files\n\u2502\u2500\u2500 transcript_tiles\n\u2514\u2500\u2500 xenium_transform.csv\n\n</code></pre> <p>The LandscapeFiles for an an example public 10X Genomics Xenium dataset can be found here.</p>"},{"location":"overview/file_formats/#cell-by-gene","title":"Cell-by-Gene","text":"<p>The <code>cbg</code> directory contains parquet files for each gene. Each file has a table of all the non-zero single cell expression counts. See example below:</p> <pre><code>    A2ML1\naaaaljij-1  18\naaabgfcl-1  24\naaacghkb-1  28\naaachnfg-1  14\naaacknep-1  1\n\n</code></pre>"},{"location":"overview/file_formats/#cell-clusters","title":"Cell Clusters","text":"<p>The <code>cell_clusters</code> directory contains single-cell clustering data. For Xenium data, these will include the default clustering results stored in two parquet files.</p>"},{"location":"overview/file_formats/#clusterparquet","title":"cluster.parquet","text":"<p>This file contains the cluster identity of each cell. See example below:</p> <pre><code>    cluster\naaaaljij-1  28\naaabgfcl-1  27\naaacghkb-1  27\naaachnfg-1  28\naaacknep-1  28\n\n</code></pre>"},{"location":"overview/file_formats/#meta_clusterparquet","title":"meta_cluster.parquet","text":"<p>This file contains metadata on the cell clusters, which includes the color and cell count. See example below:</p> <pre><code>    color   count\n1   #1f77b4 12742\n2   #ff7f0e 10058\n3   #2ca02c 9171\n4   #d62728 8781\n5   #9467bd 7760\n\n</code></pre>"},{"location":"overview/file_formats/#cell-metadata","title":"Cell Metadata","text":"<p>The <code>cell_metadata.parquet</code> file contains the centroid positions of all cells. See example below:</p> <pre><code>cell_id name    geometry\n\naaaaljij-1  aaaaljij-1  [819.7626194690856, 10819.416697734863]\naaabgfcl-1  aaabgfcl-1  [861.7377139772034, 10683.254024123535]\naaacghkb-1  aaacghkb-1  [876.8403955191346, 10627.146491566895]\naaachnfg-1  aaachnfg-1  [799.6315031020813, 10692.094786328125]\naaacknep-1  aaacknep-1  [760.0623424668274, 10729.360408533203]\n\n</code></pre>"},{"location":"overview/file_formats/#cell-segmentation","title":"Cell Segmentation","text":"<p>The <code>cell_segmentation</code> directory contains tiled parquet files that contain cell segmentation polygons for the cells within a given tile. See example below:</p> <pre><code>cell_id GEOMETRY    name\n\nmnnojdjm-1  [[[35052.998290142576, 2648.999973659546], [35...   mnnojdjm-1\nmnoafgkh-1  [[[35229.99735775, 2654.999800875], [35227.998...   mnoafgkh-1\nmnodjmcf-1  [[[35090.99920641015, 2657.9998580948486], [35...   mnodjmcf-1\nmoelbbjj-1  [[[35233.997817008785, 2602.9998622198486], [3...   moelbbjj-1\nmoemfhce-1  [[[35242.998275892576, 2539.9998095], [35239.9...   moemfhce-1\n\n</code></pre>"},{"location":"overview/file_formats/#cell-cluster-gene-expression-signatures","title":"Cell Cluster Gene Expression Signatures","text":"<p>The <code>df_sig.parquet</code> file contains the gene expression signatures of the cell clusters - defined as the average gene expression level of a cluster's cells. See example below:</p> <pre><code>    1   2   3   4   5   6   7   8   9   10  ... 20  21  22  23  24  25  26  27  28  29\nA2ML1   0.000235    0.000597    0.000109    0.000114    0.002320    0.000823    0.000996    0.000372    0.000760    0.000473    ... 0.018356    0.0000  0.000000    0.000000    0.000000    0.000000    2.593168    8.309091    5.602632    0.000000\nAAMP    0.296029    0.298668    0.032494    0.052727    0.003222    0.515027    0.014938    0.070061    0.395857    0.470894    ... 0.122905    0.0960  0.429596    0.058206    0.128743    0.511224    0.580745    0.456566    0.136842    0.052632\nAAR2    0.075655    0.069994    0.015375    0.023118    0.002964    0.118705    0.006971    0.038840    0.091410    0.117132    ... 0.054270    0.0424  0.129148    0.022901    0.030938    0.130612    0.154244    0.117172    0.057895    0.021053\nAARSD1  0.074557    0.156194    0.013412    0.017880    0.001546    0.200357    0.005477    0.028805    0.121057    0.120208    ... 0.047087    0.0272  0.093274    0.019084    0.028942    0.223469    0.120083    0.024242    0.005263    0.010526\nABAT    0.004787    0.008053    0.009814    0.015830    0.000902    0.009743    0.004481    0.004832    0.003801    0.006626    ... 0.008779    0.0072  0.004484    0.017176    0.008982    0.002041    0.006211    0.002020    0.000000    0.005263\n</code></pre>"},{"location":"overview/file_formats/#landscape-parameters","title":"Landscape Parameters","text":"<p>This file contains the configuration information about the dataset. See example below:</p> <pre><code>{\n    \"technology\": \"Xenium\",\n    \"max_pyramid_zoom\": 16,\n    \"tile_size\": 250,\n    \"image_info\": [\n        {\n            \"name\": \"dapi\",\n            \"button_name\": \"DAPI\",\n            \"color\": [\n                0,\n                0,\n                255\n            ]\n        },\n        {\n            \"name\": \"bound\",\n            \"button_name\": \"BOUND\",\n            \"color\": [\n                0,\n                255,\n                0\n            ]\n        },\n        {\n            \"name\": \"rna\",\n            \"button_name\": \"RNA\",\n            \"color\": [\n                255,\n                0,\n                0\n            ]\n        },\n        {\n            \"name\": \"prot\",\n            \"button_name\": \"PROT\",\n            \"color\": [\n                255,\n                255,\n                255\n            ]\n        }\n    ],\n    \"image_format\": \".webp\"\n}\n</code></pre>"},{"location":"overview/file_formats/#gene-metadata","title":"Gene Metadata","text":"<p>The <code>gene_metadata.parquet</code> file contains gene level metadata including: average expression across all cells, standard deviation, max expression, proportion of cells with non-zero expression, and the color assigned to each gene. See example below:</p> <pre><code>    mean    std max non-zero    color\nA2ML1   0.078391    3.128721    46.0    0.000009    #1f77b4\nAAMP    0.175449    1.621841    7.0 0.000009    #ff7f0e\nAAR2    0.048494    0.780702    4.0 0.000009    #2ca02c\nAARSD1  0.060533    0.897824    4.0 0.000009    #d62728\nABAT    0.006575    0.285613    3.0 0.000009    #9467bd\n\n</code></pre>"},{"location":"overview/file_formats/#pyramid-images","title":"Pyramid Images","text":"<p>The <code>pyramid_images</code> directory contains iST images from all available channels saved  Deep Zoom pyramids using the image file format WebP. An example directory structure for a Xenium multi-modal dataset looks like:</p> <pre><code>.\n\u251c\u2500\u2500 bound.dzi\n\u251c\u2500\u2500 bound_files\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 0\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 1\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 10\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 11\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 12\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 13\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 14\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 15\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 16\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 2\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 3\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 4\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 5\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 6\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 7\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 8\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 9\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 vips-properties.xml\n\u251c\u2500\u2500 dapi.dzi\n\u251c\u2500\u2500 dapi_files\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 0\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 1\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 10\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 11\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 12\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 13\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 14\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 15\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 16\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 2\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 3\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 4\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 5\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 6\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 7\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 8\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 9\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 vips-properties.xml\n\u251c\u2500\u2500 prot.dzi\n\u251c\u2500\u2500 prot_files\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 0\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 1\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 10\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 11\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 12\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 13\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 14\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 15\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 16\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 2\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 3\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 4\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 5\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 6\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 7\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 8\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 9\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 vips-properties.xml\n\u251c\u2500\u2500 rna.dzi\n\u2514\u2500\u2500 rna_files\n    \u251c\u2500\u2500 0\n    \u251c\u2500\u2500 1\n    \u251c\u2500\u2500 10\n    \u251c\u2500\u2500 11\n    \u251c\u2500\u2500 12\n    \u251c\u2500\u2500 13\n    \u251c\u2500\u2500 14\n    \u251c\u2500\u2500 15\n    \u251c\u2500\u2500 16\n    \u251c\u2500\u2500 2\n    \u251c\u2500\u2500 3\n    \u251c\u2500\u2500 4\n    \u251c\u2500\u2500 5\n    \u251c\u2500\u2500 6\n    \u251c\u2500\u2500 7\n    \u251c\u2500\u2500 8\n    \u251c\u2500\u2500 9\n    \u2514\u2500\u2500 vips-properties.xml\n\n</code></pre>"},{"location":"overview/file_formats/#transcript-tiles","title":"Transcript Tiles","text":"<p>The <code>transcript_tiles</code> directory contains tiled parquet files that contain transcript data for transcripts within a given tile. See example below:</p> <pre><code>    name    geometry\n20862147    AARSD1  [25663.38, 11758.09]\n20862230    ABCA1   [25650.44, 11757.28]\n20862780    ABCD1   [25634.19, 11754.12]\n20862819    ABCD1   [25635.51, 11755.29]\n20863051    ABHD6   [25506.54, 11753.75]\n\n</code></pre>"},{"location":"overview/file_formats/#image-transformation","title":"Image Transformation","text":"<p>The <code>xenium_transform.csv</code> file contains the 3x3 image transformation matrix to transition from physical coordinates into image coordinates.</p>"},{"location":"overview/file_formats/#sst-landscapefiles","title":"sST LandscapeFiles","text":""},{"location":"overview/getting_started/","title":"Getting Started","text":"<p>Celldega is a spatial analysis and visualization library that is being developed by the Spatial Technology Platform at the Broad Institute of MIT and Harvard. Celldega can be used as a Jupyter Widget in Python as well as a stand-alone JavaScript library.</p> <p>Please see examples notebooks below to try out Celldega in a Jupyter notebook or ObservableHQ JavaScript notebook:</p> <ul> <li>Celldega_Xenium_Landscape_Visualizations_Colab.ipynb</li> <li>Celldega Landscape Xenium ObservableHQ</li> </ul>"},{"location":"overview/installation/","title":"Installation","text":""},{"location":"overview/installation/#python","title":"Python","text":"<p>The Celldega library can be installed using pip</p> <p>Celldega can be installed using pip:</p> <pre><code>pip install celldega\n</code></pre> <p>Celldega can also be installed with the optional pre-processing requirements (e.g., vips for image pre-processing) using:</p> <pre><code>pip install celldega[pre]\n</code></pre>"},{"location":"overview/installation/#javascript","title":"JavaScript","text":"<p>Celldega can be used in a JavaScript environment such as ObservableHQ by importing it as a module from content delivery networks like esm.sh:</p> <pre><code>celldega = await import('https://esm.sh/celldega@latest')\n</code></pre> <p>Or by importing it from a local file</p> <pre><code>import celldega from 'js/widget.js'\n</code></pre>"},{"location":"overview/usage/","title":"Celldega Usage","text":""},{"location":"overview/usage/#terrabio","title":"Terra.bio","text":"<p>** Coming soon **</p>"},{"location":"python/","title":"Python API Overview","text":""},{"location":"python/#neighborhood-overview","title":"Neighborhood Overview","text":"<p>The <code>nbhd</code> module contains methods for calculating tissue neighborhoods.</p>"},{"location":"python/#pre-module-overview","title":"Pre Module Overview","text":"<p>The <code>pre</code> module contains methods for pre-processing LandscapeFiles.</p>"},{"location":"python/#viz-module-overview","title":"Viz Module Overview","text":"<p>The <code>viz</code> module contains functions and classes for data visualization.</p>"},{"location":"python/api/","title":"Python API Reference","text":"<p>Module for pre-processing to generate LandscapeFiles from ST data.</p> <p>Module for visualization</p>"},{"location":"python/api/#celldega.nbhd.alpha_shape_cell_clusters","title":"<code>alpha_shape_cell_clusters(meta_cell, cat='cluster', alphas=[100, 150, 200, 250, 300, 350])</code>","text":"<p>Compute alpha shapes for each cluster in the cell metadata.</p> <p>Parameters: - meta_cell: GeoDataFrame of cell metadata. - cat: Column name in meta_cell containing the cluster labels. - alphas: List of alpha values to compute shapes for.</p> <p>Returns: - GeoDataFrame of alpha shapes.</p> Source code in <code>src/celldega/nbhd/__init__.py</code> <pre><code>def alpha_shape_cell_clusters(meta_cell, cat='cluster', alphas=[100, 150, 200, 250, 300, 350]):\n\n    \"\"\"\n    Compute alpha shapes for each cluster in the cell metadata.\n\n    Parameters:\n    - meta_cell: GeoDataFrame of cell metadata.\n    - cat: Column name in meta_cell containing the cluster labels.\n    - alphas: List of alpha values to compute shapes for.\n\n    Returns:\n    - GeoDataFrame of alpha shapes.\n\n    \"\"\"\n\n    gdf_alpha = gpd.GeoDataFrame()\n\n    for inv_alpha in alphas:\n\n        for inst_cluster in meta_cell[cat].unique():\n\n            inst_clust = meta_cell[meta_cell[cat] == inst_cluster]\n\n            if inst_clust.shape[0]&gt; 3:\n\n                nested_array = inst_clust['geometry'].values\n\n                # Convert to a 2D NumPy array\n                flat_array = np.vstack(nested_array)\n\n                inst_shape = alpha_shape(flat_array, inv_alpha)\n\n                inst_name = inst_cluster + '_' + str(inv_alpha)\n\n                gdf_alpha.loc[inst_name, 'name'] = inst_name\n\n                gdf_alpha.loc[inst_name, 'cat'] = inst_cluster\n\n                gdf_alpha.loc[inst_name, 'geometry'] = inst_shape\n\n                gdf_alpha.loc[inst_name, 'inv_alpha'] = int(inv_alpha)\n\n    gdf_alpha[\"geometry\"] = gdf_alpha[\"geometry\"].apply(lambda geom: _round_coordinates(geom, precision=2))\n\n    gdf_alpha['area'] = gdf_alpha.area\n\n    gdf_alpha = gdf_alpha.loc[gdf_alpha.area.sort_values(ascending=False).index.tolist()]\n\n    return gdf_alpha\n</code></pre>"},{"location":"python/api/#celldega.pre.calc_meta_gene_data","title":"<code>calc_meta_gene_data(cbg)</code>","text":"<p>Calculate gene metadata from the cell-by-gene matrix</p> <p>Parameters:</p> Name Type Description Default <code>cbg</code> <code>DataFrame</code> <p>A sparse DataFrame with genes as columns and barcodes as rows.</p> required <p>Returns:</p> Type Description <p>pandas.DataFrame: A DataFrame with gene metadata including mean, standard deviation, maximum expression, and proportion of non-zero expression.</p> Source code in <code>src/celldega/pre/landscape.py</code> <pre><code>def calc_meta_gene_data(cbg):\n    \"\"\"\n    Calculate gene metadata from the cell-by-gene matrix\n\n    Args:\n        cbg (pandas.DataFrame): A sparse DataFrame with genes as columns and barcodes as rows.\n\n    Returns:\n        pandas.DataFrame: A DataFrame with gene metadata including mean, standard deviation,\n            maximum expression, and proportion of non-zero expression.\n    \"\"\"\n\n    # Helper function to convert to dense if sparse\n    def convert_to_dense(series):\n        \"\"\"\n        Convert a pandas Series to dense format if it's sparse.\n\n        Parameters\n        ----------\n        series : pandas.Series\n\n        Returns\n        -------\n        pandas.Series\n            Dense Series if input was sparse; original Series otherwise.\n        \"\"\"\n        if pd.api.types.is_sparse(series):\n            return series.sparse.to_dense()\n        return series\n\n    # Ensure cbg is a DataFrame\n    if not isinstance(cbg, pd.DataFrame):\n        raise TypeError(\"cbg must be a pandas DataFrame\")\n\n    # Determine if cbg is sparse\n    is_sparse = pd.api.types.is_sparse(cbg)\n\n    if is_sparse:\n        # Ensure cbg has SparseDtype with float and fill_value=0\n        cbg = cbg.astype(pd.SparseDtype(\"float\", fill_value=0))\n        print(\"cbg is a sparse DataFrame. Proceeding with sparse operations.\")\n    else:\n        print(\"cbg is a dense DataFrame. Proceeding with dense operations.\")\n\n    # Calculate mean expression across tiles\n    print(\"Calculating mean expression\")\n    mean_expression = cbg.mean(axis=0)\n\n    # Calculate variance as the average of the squared deviations\n    print(\"Calculating variance\")\n    num_tiles = cbg.shape[1]\n    variance = cbg.apply(\n        lambda x: ((x - mean_expression[x.name]) ** 2).sum() / num_tiles, axis=0\n    )\n    std_deviation = np.sqrt(variance)\n\n    # Calculate maximum expression\n    max_expression = cbg.max(axis=0)\n\n    # Calculate proportion of tiles with non-zero expression\n    proportion_nonzero = (cbg != 0).sum(axis=0) / len(cbg)\n\n    # Create a DataFrame to hold all these metrics\n    meta_gene = pd.DataFrame(\n        {\n            \"mean\": mean_expression.sparse.to_dense(),\n            \"std\": std_deviation,\n            \"max\": max_expression.sparse.to_dense(),\n            \"non-zero\": proportion_nonzero.sparse.to_dense(),\n        }\n\n    )\n\n    meta_gene_clean = pd.DataFrame(meta_gene.values, index=meta_gene.index.tolist(), columns=meta_gene.columns)\n\n    return meta_gene_clean\n</code></pre>"},{"location":"python/api/#celldega.pre.convert_long_id_to_short","title":"<code>convert_long_id_to_short(df)</code>","text":"<p>Converts a column of long integer cell IDs in a DataFrame to a shorter, hash-based representation.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The DataFrame containing the EntityID.</p> required <p>Returns:     pd.DataFrame: The original DataFrame with an additional column named <code>cell_id</code>                   containing the shortened cell IDs.</p> <p>The function applies a SHA-256 hash to each cell ID, encodes the hash using base64, and truncates it to create a shorter identifier that is added as a new column to the DataFrame.</p> Source code in <code>src/celldega/pre/__init__.py</code> <pre><code>def convert_long_id_to_short(df):\n    \"\"\"\n    Converts a column of long integer cell IDs in a DataFrame to a shorter, hash-based representation.\n\n    Args:\n        df (pd.DataFrame): The DataFrame containing the EntityID.\n    Returns:\n        pd.DataFrame: The original DataFrame with an additional column named `cell_id`\n                      containing the shortened cell IDs.\n\n    The function applies a SHA-256 hash to each cell ID, encodes the hash using base64, and truncates\n    it to create a shorter identifier that is added as a new column to the DataFrame.\n    \"\"\"\n    # Function to hash and encode the cell ID\n    def hash_and_shorten_id(cell_id):\n        # Create a hash of the cell ID\n        cell_id_bytes = str(cell_id).encode('utf-8')\n        hash_object = hashlib.sha256(cell_id_bytes)\n        hash_digest = hash_object.digest()\n\n        # Encode the hash to a base64 string to mix letters and numbers, truncate to 9 characters\n        short_id = base64.urlsafe_b64encode(hash_digest).decode('utf-8')[:9]\n        return short_id\n\n    # Apply the hash_and_shorten_id function to each cell ID in the specified column\n    df['cell_id'] = df['EntityID'].apply(hash_and_shorten_id)\n\n    return df\n</code></pre>"},{"location":"python/api/#celldega.pre.convert_to_jpeg","title":"<code>convert_to_jpeg(image_path, quality=80)</code>","text":"<p>Convert a TIFF image to a JPEG image with a quality of score</p>"},{"location":"python/api/#celldega.pre.convert_to_jpeg--parameters","title":"Parameters","text":"<p>image_path : str     Path to the image file quality : int (default=80)     Quality score for the JPEG image</p>"},{"location":"python/api/#celldega.pre.convert_to_jpeg--returns","title":"Returns","text":"<p>new_image_path : str     Path to the JPEG image file</p> Source code in <code>src/celldega/pre/__init__.py</code> <pre><code>def convert_to_jpeg(image_path, quality=80):\n    \"\"\"\n    Convert a TIFF image to a JPEG image with a quality of score\n\n    Parameters\n    ----------\n    image_path : str\n        Path to the image file\n    quality : int (default=80)\n        Quality score for the JPEG image\n\n    Returns\n    -------\n    new_image_path : str\n        Path to the JPEG image file\n\n    \"\"\"\n\n    # Load the TIFF image\n    image = pyvips.Image.new_from_file(image_path, access=\"sequential\")\n\n    # Save the image as a JPEG with a quality of 80\n    new_image_path = image_path.replace(\".tif\", \".jpeg\")\n    image.jpegsave(new_image_path, Q=quality)\n\n    return new_image_path\n</code></pre>"},{"location":"python/api/#celldega.pre.convert_to_png","title":"<code>convert_to_png(image_path)</code>","text":"<p>Convert a TIFF image to a JPEG image with a quality of score</p>"},{"location":"python/api/#celldega.pre.convert_to_png--parameters","title":"Parameters","text":"<p>image_path : str     Path to the image file quality : int (default=80)     Quality score for the JPEG image</p>"},{"location":"python/api/#celldega.pre.convert_to_png--returns","title":"Returns","text":"<p>new_image_path : str     Path to the JPEG image file</p> Source code in <code>src/celldega/pre/__init__.py</code> <pre><code>def convert_to_png(image_path):\n    \"\"\"\n    Convert a TIFF image to a JPEG image with a quality of score\n\n    Parameters\n    ----------\n    image_path : str\n        Path to the image file\n    quality : int (default=80)\n        Quality score for the JPEG image\n\n    Returns\n    -------\n    new_image_path : str\n        Path to the JPEG image file\n\n    \"\"\"\n\n    # Load the TIFF image\n    image = pyvips.Image.new_from_file(image_path, access=\"sequential\")\n\n    # Save the image as a JPEG with a quality of 80\n    new_image_path = image_path.replace(\".tif\", \".png\")\n    image.pngsave(new_image_path)\n\n    return new_image_path\n</code></pre>"},{"location":"python/api/#celldega.pre.convert_to_webp","title":"<code>convert_to_webp(image_path, quality=100)</code>","text":"<p>Convert a TIFF image to a WEBP image with a specified quality score.</p>"},{"location":"python/api/#celldega.pre.convert_to_webp--parameters","title":"Parameters","text":"<p>image_path : str     Path to the image file quality : int (default=100)     Quality score for the WEBP image (higher is better quality)</p>"},{"location":"python/api/#celldega.pre.convert_to_webp--returns","title":"Returns","text":"<p>new_image_path : str     Path to the WEBP image file</p> Source code in <code>src/celldega/pre/__init__.py</code> <pre><code>def convert_to_webp(image_path, quality=100):\n    \"\"\"\n    Convert a TIFF image to a WEBP image with a specified quality score.\n\n    Parameters\n    ----------\n    image_path : str\n        Path to the image file\n    quality : int (default=100)\n        Quality score for the WEBP image (higher is better quality)\n\n    Returns\n    -------\n    new_image_path : str\n        Path to the WEBP image file\n    \"\"\"\n    # Load the TIFF image\n    image = pyvips.Image.new_from_file(image_path, access=\"sequential\")\n\n    # Save the image as a WEBP with specified quality\n    new_image_path = image_path.replace(\".tif\", \".webp\")\n    image.webpsave(new_image_path, Q=quality)\n\n    return new_image_path\n</code></pre>"},{"location":"python/api/#celldega.pre.get_max_zoom_level","title":"<code>get_max_zoom_level(path_image_pyramid)</code>","text":"<p>Returns the maximum zoom level based on the highest-numbered directory in the specified path_image_pyramid.</p> <p>Parameters:</p> Name Type Description Default <code>path_image_pyramid</code> <code>str</code> <p>The path to the directory containing zoom level directories.</p> required <p>Returns:</p> Name Type Description <code>max_pyramid_zoom</code> <code>int</code> <p>The maximum zoom level.</p> Source code in <code>src/celldega/pre/__init__.py</code> <pre><code>def get_max_zoom_level(path_image_pyramid):\n    \"\"\"\n    Returns the maximum zoom level based on the highest-numbered directory\n    in the specified path_image_pyramid.\n\n    Parameters:\n        path_image_pyramid (str): The path to the directory containing zoom level directories.\n\n    Returns:\n        max_pyramid_zoom (int): The maximum zoom level.\n    \"\"\"\n    # List all entries in the path_image_pyramid that are directories and can be converted to integers\n    zoom_levels = [\n        entry\n        for entry in os.listdir(path_image_pyramid)\n        if os.path.isdir(os.path.join(path_image_pyramid, entry)) and entry.isdigit()\n    ]\n\n    # Convert to integer and find the maximum value\n    max_pyramid_zoom = max(map(int, zoom_levels)) if zoom_levels else None\n\n    return max_pyramid_zoom\n</code></pre>"},{"location":"python/api/#celldega.pre.make_cell_boundary_tiles","title":"<code>make_cell_boundary_tiles(technology, path_cell_boundaries, path_meta_cell_micron, path_transformation_matrix, path_output, coarse_tile_factor=20, tile_size=250, tile_bounds=None, image_scale=1, max_workers=8)</code>","text":"<p>Processes cell boundary data and divides it into spatial tiles based on the provided technology. Reads cell boundary data, applies affine transformations, and divides the data into coarse and fine tiles. The resulting tiles are saved as Parquet files, each containing the geometries of cells in that tile.</p>"},{"location":"python/api/#celldega.pre.make_cell_boundary_tiles--parameters","title":"Parameters","text":"<p>technology : str     The technology used to generate the cell boundary data, e.g., \"MERSCOPE\", \"Xenium\", or \"custom\". path_cell_boundaries : str     Path to the file containing the cell boundaries (Parquet format). path_meta_cell_micron : str     Path to the file containing cell metadata (CSV format). path_transformation_matrix : str     Path to the file containing the transformation matrix (CSV format). path_output : str     Directory path where the output files (Parquet files) for each tile will be saved. coarse_tile_factor  : int, optional, default=20.     scaling factor of each coarse-grain tile comparing to the fine tile size. tile_size : int, optional, default=500     Size of each fine-grain tile in microns. tile_bounds : dict, optional     Dictionary containing the minimum and maximum bounds for x and y coordinates. image_scale : float, optional, default=1     Scale factor to apply to the geometry data. max_workers : int, optional, default=8     Maximum number of parallel workers for processing tiles.</p>"},{"location":"python/api/#celldega.pre.make_cell_boundary_tiles--returns","title":"Returns","text":"<p>None</p> Source code in <code>src/celldega/pre/boundary_tile.py</code> <pre><code>def make_cell_boundary_tiles(\n    technology,\n    path_cell_boundaries,\n    path_meta_cell_micron,\n    path_transformation_matrix,\n    path_output,\n    coarse_tile_factor=20,\n    tile_size=250,\n    tile_bounds=None,\n    image_scale=1,\n    max_workers=8\n):\n\n\n    \"\"\"\n    Processes cell boundary data and divides it into spatial tiles based on the provided technology.\n    Reads cell boundary data, applies affine transformations, and divides the data into coarse and fine tiles.\n    The resulting tiles are saved as Parquet files, each containing the geometries of cells in that tile.\n\n    Parameters\n    ----------\n    technology : str\n        The technology used to generate the cell boundary data, e.g., \"MERSCOPE\", \"Xenium\", or \"custom\".\n    path_cell_boundaries : str\n        Path to the file containing the cell boundaries (Parquet format).\n    path_meta_cell_micron : str\n        Path to the file containing cell metadata (CSV format).\n    path_transformation_matrix : str\n        Path to the file containing the transformation matrix (CSV format).\n    path_output : str\n        Directory path where the output files (Parquet files) for each tile will be saved.\n    coarse_tile_factor  : int, optional, default=20.\n        scaling factor of each coarse-grain tile comparing to the fine tile size.\n    tile_size : int, optional, default=500\n        Size of each fine-grain tile in microns.\n    tile_bounds : dict, optional\n        Dictionary containing the minimum and maximum bounds for x and y coordinates.\n    image_scale : float, optional, default=1\n        Scale factor to apply to the geometry data.\n    max_workers : int, optional, default=8\n        Maximum number of parallel workers for processing tiles.\n\n    Returns\n    -------\n    None\n    \"\"\"\n\n    def numpy_affine_transform(coords, matrix):\n        \"\"\"Apply affine transformation to numpy coordinates.\"\"\"\n        # Homogeneous coordinates for affine transformation\n        coords = np.hstack([coords, np.ones((coords.shape[0], 1))])\n        transformed_coords = coords @ matrix.T\n        return transformed_coords[:, :2]  # Drop the homogeneous coordinate\n\n    def batch_transform_geometries(geometries, transformation_matrix, scale):\n        \"\"\"\n        Batch transform geometries using numpy for optimized performance.\n        \"\"\"\n        # Extract affine transformation parameters into a 3x3 matrix for numpy\n        affine_matrix = np.array([\n            [transformation_matrix[0, 0], transformation_matrix[0, 1], transformation_matrix[0, 2]],\n            [transformation_matrix[1, 0], transformation_matrix[1, 1], transformation_matrix[1, 2]],\n            [0, 0, 1]\n        ])\n\n        transformed_geometries = []\n\n        for polygon in geometries:\n            # Extract coordinates and transform them\n            if isinstance(polygon, MultiPolygon):\n                polygon = next(polygon.geoms)  # Use the first geometry\n\n            # Transform the exterior of the polygon\n            exterior_coords = np.array(polygon.exterior.coords)\n\n            # Apply the affine transformation and scale\n            transformed_coords = numpy_affine_transform(exterior_coords, affine_matrix) / scale\n\n            # Append the result to the transformed_geometries list\n            transformed_geometries.append([transformed_coords.tolist()])\n\n        return transformed_geometries\n\n\n    def filter_and_save_fine_boundary(coarse_tile, fine_i, fine_j, fine_tile_x_min, fine_tile_x_max, fine_tile_y_min, fine_tile_y_max, path_output):\n        cell_ids = coarse_tile.index.values\n\n        tile_filter = (\n            (coarse_tile[\"center_x\"] &gt;= fine_tile_x_min) &amp; (coarse_tile[\"center_x\"] &lt; fine_tile_x_max) &amp;\n            (coarse_tile[\"center_y\"] &gt;= fine_tile_y_min) &amp; (coarse_tile[\"center_y\"] &lt; fine_tile_y_max)\n        )\n        filtered_indices = np.where(tile_filter)[0]\n\n        keep_cells = cell_ids[filtered_indices]\n        fine_tile_cells = coarse_tile.loc[keep_cells, [\"GEOMETRY\"]]\n        fine_tile_cells = fine_tile_cells.assign(name=fine_tile_cells.index)\n\n        if not fine_tile_cells.empty:\n            filename = f\"{path_output}/cell_tile_{fine_i}_{fine_j}.parquet\"\n            fine_tile_cells.to_parquet(filename)\n\n    def process_fine_boundaries(coarse_tile, i, j, coarse_tile_x_min, coarse_tile_x_max, coarse_tile_y_min, coarse_tile_y_max, tile_size, path_output, x_min, y_min, n_fine_tiles_x, n_fine_tiles_y):\n        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:\n            futures = []\n            for fine_i in range(n_fine_tiles_x):\n                fine_tile_x_min = x_min + fine_i * tile_size\n                fine_tile_x_max = fine_tile_x_min + tile_size\n\n                if not (fine_tile_x_min &gt;= coarse_tile_x_min and fine_tile_x_max &lt;= coarse_tile_x_max):\n                    continue\n\n                for fine_j in range(n_fine_tiles_y):\n                    fine_tile_y_min = y_min + fine_j * tile_size\n                    fine_tile_y_max = fine_tile_y_min + tile_size\n\n                    if not (fine_tile_y_min &gt;= coarse_tile_y_min and fine_tile_y_max &lt;= coarse_tile_y_max):\n                        continue\n\n                    futures.append(executor.submit(\n                        filter_and_save_fine_boundary, coarse_tile, fine_i, fine_j, fine_tile_x_min, fine_tile_x_max, fine_tile_y_min, fine_tile_y_max, path_output\n                    ))\n\n            for future in futures:\n                future.result()\n\n    tile_size_x = tile_size\n    tile_size_y = tile_size\n\n    transformation_matrix = pd.read_csv(path_transformation_matrix, header=None, sep=\" \").values\n\n    # Load cell boundary data based on the technology\n    if technology == \"MERSCOPE\":\n        df_meta = pd.read_parquet(f\"{path_output.replace('cell_segmentation','cell_metadata.parquet')}\")\n        entity_to_cell_id_dict = pd.Series(df_meta.index.values, index=df_meta.EntityID).to_dict()\n        cells_orig = gpd.read_parquet(path_cell_boundaries)\n        cells_orig['cell_id'] = cells_orig['EntityID'].map(entity_to_cell_id_dict)\n        cells_orig = cells_orig[cells_orig[\"ZIndex\"] == 1]\n\n        # Correct cell_id issues with meta_cell\n        meta_cell = pd.read_csv(path_meta_cell_micron)\n        meta_cell['cell_id'] = meta_cell['EntityID'].map(entity_to_cell_id_dict)\n        cells_orig.index = meta_cell[meta_cell[\"cell_id\"].isin(cells_orig['cell_id'])].index\n\n        # Correct 'MultiPolygon' to 'Polygon'\n        cells_orig[\"geometry\"] = cells_orig[\"Geometry\"].apply(\n            lambda x: list(x.geoms)[0] if isinstance(x, MultiPolygon) else x\n        )\n\n        cells_orig.set_index('cell_id', inplace=True)\n\n    elif technology == \"Xenium\":\n        xenium_cells = pd.read_parquet(path_cell_boundaries)\n        grouped = xenium_cells.groupby(\"cell_id\")[[\"vertex_x\", \"vertex_y\"]].agg(lambda x: x.tolist())\n        grouped[\"geometry\"] = grouped.apply(lambda row: Polygon(zip(row[\"vertex_x\"], row[\"vertex_y\"])), axis=1)\n        cells_orig = gpd.GeoDataFrame(grouped, geometry=\"geometry\")[[\"geometry\"]]\n\n    elif technology == \"custom\":\n        cells_orig = gpd.read_parquet(path_cell_boundaries)\n\n    # Transform geometries\n    cells_orig[\"GEOMETRY\"] = batch_transform_geometries(cells_orig[\"geometry\"], transformation_matrix, image_scale)\n\n    # Convert transformed geometries to polygons and calculate centroids\n    cells_orig[\"polygon\"] = cells_orig[\"GEOMETRY\"].apply(lambda x: Polygon(x[0]))\n    gdf_cells = gpd.GeoDataFrame(geometry=cells_orig[\"polygon\"])\n    gdf_cells[\"center_x\"] = gdf_cells.geometry.centroid.x\n    gdf_cells[\"center_y\"] = gdf_cells.geometry.centroid.y\n    gdf_cells[\"GEOMETRY\"] = cells_orig[\"GEOMETRY\"]\n\n    # Ensure the output directory exists\n    if not os.path.exists(path_output):\n        os.makedirs(path_output)\n\n    # Calculate tile bounds and fine/coarse tiles\n    x_min, x_max = tile_bounds[\"x_min\"], tile_bounds[\"x_max\"]\n    y_min, y_max = tile_bounds[\"y_min\"], tile_bounds[\"y_max\"]\n    n_fine_tiles_x = int(np.ceil((x_max - x_min) / tile_size))\n    n_fine_tiles_y = int(np.ceil((y_max - y_min) / tile_size))\n    n_coarse_tiles_x = int(np.ceil((x_max - x_min) / (coarse_tile_factor * tile_size)))\n    n_coarse_tiles_y = int(np.ceil((y_max - y_min) / (coarse_tile_factor * tile_size)))\n\n    # Process coarse tiles in parallel\n    for i in tqdm(range(n_coarse_tiles_x), desc=\"Processing coarse tiles\"):\n        coarse_tile_x_min = x_min + i * (coarse_tile_factor * tile_size)\n        coarse_tile_x_max = coarse_tile_x_min + (coarse_tile_factor * tile_size)\n\n        for j in range(n_coarse_tiles_y):\n            coarse_tile_y_min = y_min + j * (coarse_tile_factor * tile_size)\n            coarse_tile_y_max = coarse_tile_y_min + (coarse_tile_factor * tile_size)\n\n            coarse_tile = gdf_cells[\n                (gdf_cells[\"center_x\"] &gt;= coarse_tile_x_min) &amp; (gdf_cells[\"center_x\"] &lt; coarse_tile_x_max) &amp;\n                (gdf_cells[\"center_y\"] &gt;= coarse_tile_y_min) &amp; (gdf_cells[\"center_y\"] &lt; coarse_tile_y_max)\n            ]\n            if not coarse_tile.empty:\n                process_fine_boundaries(coarse_tile, i, j, coarse_tile_x_min, coarse_tile_x_max, coarse_tile_y_min, coarse_tile_y_max, tile_size, path_output, x_min, y_min, n_fine_tiles_x, n_fine_tiles_y)\n</code></pre>"},{"location":"python/api/#celldega.pre.make_deepzoom_pyramid","title":"<code>make_deepzoom_pyramid(image_path, output_path, pyramid_name, tile_size=512, overlap=0, suffix='.jpeg')</code>","text":"<p>Create a DeepZoom image pyramid from a JPEG image</p>"},{"location":"python/api/#celldega.pre.make_deepzoom_pyramid--parameters","title":"Parameters","text":"<p>image_path : str     Path to the JPEG image file tile_size : int (default=512)     Tile size for the DeepZoom pyramid overlap : int (default=0)     Overlap size for the DeepZoom pyramid suffix : str (default='jpeg')     Suffix for the DeepZoom pyramid tiles</p>"},{"location":"python/api/#celldega.pre.make_deepzoom_pyramid--returns","title":"Returns","text":"<p>None</p> Source code in <code>src/celldega/pre/__init__.py</code> <pre><code>def make_deepzoom_pyramid(\n    image_path, output_path, pyramid_name, tile_size=512, overlap=0, suffix=\".jpeg\"\n):\n    \"\"\"\n    Create a DeepZoom image pyramid from a JPEG image\n\n    Parameters\n    ----------\n    image_path : str\n        Path to the JPEG image file\n    tile_size : int (default=512)\n        Tile size for the DeepZoom pyramid\n    overlap : int (default=0)\n        Overlap size for the DeepZoom pyramid\n    suffix : str (default='jpeg')\n        Suffix for the DeepZoom pyramid tiles\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n\n    # Define the output path\n    output_path = Path(output_path)\n\n    # Load the JPEG image\n    image = pyvips.Image.new_from_file(image_path, access=\"sequential\")\n\n    # check if the output path exists and create it if it does not\n    output_path.mkdir(parents=True, exist_ok=True)\n\n    # append the pyramid name to the output path\n    output_path = output_path / pyramid_name\n\n    # Save the image as a DeepZoom image pyramid\n    image.dzsave(output_path, tile_size=tile_size, overlap=overlap, suffix=suffix)\n</code></pre>"},{"location":"python/api/#celldega.pre.make_meta_cell_image_coord","title":"<code>make_meta_cell_image_coord(technology, path_transformation_matrix, path_meta_cell_micron, path_meta_cell_image, image_scale)</code>","text":"<p>Apply an affine transformation to the cell coordinates in microns and save the transformed coordinates in pixels</p>"},{"location":"python/api/#celldega.pre.make_meta_cell_image_coord--parameters","title":"Parameters","text":"<p>technology : str     The technology used to generate the data, Xenium and MERSCOPE are supported. path_transformation_matrix : str     Path to the transformation matrix file path_meta_cell_micron : str     Path to the meta cell file with coordinates in microns path_meta_cell_image : str     Path to save the meta cell file with coordinates in pixels</p>"},{"location":"python/api/#celldega.pre.make_meta_cell_image_coord--returns","title":"Returns","text":"<p>None</p>"},{"location":"python/api/#celldega.pre.make_meta_cell_image_coord--examples","title":"Examples","text":"<p>make_meta_cell_image_coord( ...     technology='Xenium', ...     path_transformation_matrix='data/transformation_matrix.txt', ...     path_meta_cell_micron='data/meta_cell_micron.csv', ...     path_meta_cell_image='data/meta_cell_image.parquet' ... )</p> Source code in <code>src/celldega/pre/__init__.py</code> <pre><code>def make_meta_cell_image_coord(\n    technology,\n    path_transformation_matrix,\n    path_meta_cell_micron,\n    path_meta_cell_image,\n    image_scale\n):\n    \"\"\"\n    Apply an affine transformation to the cell coordinates in microns and save\n    the transformed coordinates in pixels\n\n    Parameters\n    ----------\n    technology : str\n        The technology used to generate the data, Xenium and MERSCOPE are supported.\n    path_transformation_matrix : str\n        Path to the transformation matrix file\n    path_meta_cell_micron : str\n        Path to the meta cell file with coordinates in microns\n    path_meta_cell_image : str\n        Path to save the meta cell file with coordinates in pixels\n\n    Returns\n    -------\n    None\n\n    Examples\n    --------\n    &gt;&gt;&gt; make_meta_cell_image_coord(\n    ...     technology='Xenium',\n    ...     path_transformation_matrix='data/transformation_matrix.txt',\n    ...     path_meta_cell_micron='data/meta_cell_micron.csv',\n    ...     path_meta_cell_image='data/meta_cell_image.parquet'\n    ... )\n\n    \"\"\"\n\n    transformation_matrix = pd.read_csv(\n        path_transformation_matrix, header=None, sep=\" \"\n    ).values\n\n    if technology == \"MERSCOPE\":\n        meta_cell = pd.read_csv(path_meta_cell_micron, usecols=[\"EntityID\", \"center_x\", \"center_y\"])\n        meta_cell = convert_long_id_to_short(meta_cell)\n        meta_cell[\"name\"] =  meta_cell[\"cell_id\"]\n        meta_cell = meta_cell.set_index('cell_id')\n    elif technology == \"Xenium\":\n        usecols = [\"cell_id\", \"x_centroid\", \"y_centroid\"]\n        meta_cell = pd.read_csv(path_meta_cell_micron, index_col=0, usecols=usecols)\n        meta_cell.columns = [\"center_x\", \"center_y\"]\n        meta_cell[\"name\"] = pd.Series(meta_cell.index, index=meta_cell.index)\n\n    # Adding a ones column to accommodate for affine transformation\n    meta_cell[\"ones\"] = 1\n\n    # Preparing the data for matrix multiplication\n    points = meta_cell[[\"center_x\", \"center_y\", \"ones\"]].values\n\n    # Applying the transformation matrix\n    transformed_points = np.dot(transformation_matrix, points.T).T\n\n    # Updating the DataFrame with transformed coordinates\n    meta_cell[\"center_x\"] = transformed_points[:, 0]\n    meta_cell[\"center_y\"] = transformed_points[:, 1]\n\n    # Dropping the ones column as it's no longer needed\n    meta_cell.drop(columns=[\"ones\"], inplace=True)\n\n    meta_cell[\"center_x\"] = meta_cell[\"center_x\"] / image_scale\n    meta_cell[\"center_y\"] = meta_cell[\"center_y\"] / image_scale\n\n    meta_cell[\"geometry\"] = meta_cell.apply(\n        lambda row: [row[\"center_x\"], row[\"center_y\"]], axis=1\n    )\n\n    if technology == \"MERSCOPE\":\n        meta_cell = meta_cell[[\"name\", \"geometry\", \"EntityID\"]]\n    else:\n        meta_cell = meta_cell[[\"name\", \"geometry\"]]\n\n\n    meta_cell.to_parquet(path_meta_cell_image)\n</code></pre>"},{"location":"python/api/#celldega.pre.make_meta_gene","title":"<code>make_meta_gene(technology, path_cbg, path_output)</code>","text":"<p>Create a DataFrame with genes and their assigned colors</p>"},{"location":"python/api/#celldega.pre.make_meta_gene--parameters","title":"Parameters","text":"<p>technology : str     The technology used to generate the data, Xenium and MERSCOPE are supported. path_cbg : str     Path to the cell-by-gene matrix data (the data format can vary based on technology) path_output : str     Path to save the meta gene file</p>"},{"location":"python/api/#celldega.pre.make_meta_gene--returns","title":"Returns","text":"<p>None</p>"},{"location":"python/api/#celldega.pre.make_meta_gene--examples","title":"Examples","text":"<p>make_meta_gene( ...     technology='Xenium', ...     path_cbg='data/', ...     path_output='data/meta_gene.parquet' ... )</p> Source code in <code>src/celldega/pre/__init__.py</code> <pre><code>def make_meta_gene(technology, path_cbg, path_output):\n    \"\"\"\n    Create a DataFrame with genes and their assigned colors\n\n    Parameters\n    ----------\n    technology : str\n        The technology used to generate the data, Xenium and MERSCOPE are supported.\n    path_cbg : str\n        Path to the cell-by-gene matrix data (the data format can vary based on technology)\n    path_output : str\n        Path to save the meta gene file\n\n    Returns\n    -------\n    None\n\n    Examples\n    --------\n    &gt;&gt;&gt; make_meta_gene(\n    ...     technology='Xenium',\n    ...     path_cbg='data/',\n    ...     path_output='data/meta_gene.parquet'\n    ... )\n    \"\"\"\n\n    if technology == \"MERSCOPE\":\n        cbg = pd.read_csv(path_cbg, index_col=0)\n        genes = cbg.columns.tolist()\n    elif technology == \"Xenium\":\n        # genes = pd.read_csv(path_cbg + 'features.tsv.gz', sep='\\t', header=None)[1].values.tolist()\n        cbg = read_cbg_mtx(path_cbg)\n        genes = cbg.columns.tolist()\n\n    # Get all categorical color palettes from Matplotlib and flatten them into a single list of colors\n    palettes = [plt.get_cmap(name).colors for name in plt.colormaps() if \"tab\" in name]\n    flat_colors = [color for palette in palettes for color in palette]\n\n    # Convert RGB tuples to hex codes\n    flat_colors_hex = [to_hex(color) for color in flat_colors]\n\n    # Use modular arithmetic to assign a color to each gene, white for genes with \"Blank\"\n    colors = [\n        flat_colors_hex[i % len(flat_colors_hex)] if \"Blank\" not in gene else \"#FFFFFF\"\n        for i, gene in enumerate(genes)\n    ]\n\n    # Create a DataFrame with genes and their assigned colors\n    ser_color = pd.Series(colors, index=genes)\n\n    # calculate gene expression metadata\n    meta_gene = calc_meta_gene_data(cbg)\n    meta_gene['color'] = ser_color\n\n    # Identify sparse columns\n    sparse_cols = [col for col in meta_gene.columns if pd.api.types.is_sparse(meta_gene[col])]\n\n    # Convert sparse columns to dense\n    for col in sparse_cols:\n        meta_gene[col] = meta_gene[col].sparse.to_dense()\n\n    meta_gene.to_parquet(path_output)\n</code></pre>"},{"location":"python/api/#celldega.pre.make_trx_tiles","title":"<code>make_trx_tiles(technology, path_trx, path_transformation_matrix, path_trx_tiles, coarse_tile_factor=10, tile_size=250, chunk_size=1000000, verbose=False, image_scale=1, max_workers=8)</code>","text":"<p>Processes transcript data by dividing it into coarse-grain and fine-grain tiles, applying transformations, and saving the results in a parallelized manner.</p>"},{"location":"python/api/#celldega.pre.make_trx_tiles--parameters","title":"Parameters","text":"<p>technology : str     The technology used for generating the transcript data (e.g., \"MERSCOPE\" or \"Xenium\"). path_trx : str     Path to the file containing the transcript data. path_transformation_matrix : str     Path to the file containing the transformation matrix (CSV file). path_trx_tiles : str     Directory path where the output files (Parquet files) for each tile will be saved. coarse_tile_factor : int, optional     Scaling factor of each coarse-grain tile comparing to the fine tile size. tile_size : int, optional     Size of each fine-grain tile in microns (default is 250). chunk_size : int, optional     Number of rows to process per chunk for memory efficiency (default is 1000000). verbose : bool, optional     Flag to enable verbose output (default is False). image_scale : float, optional     Scale factor to apply to the transcript coordinates (default is 0.5). max_workers : int, optional     Maximum number of parallel workers for processing tiles (default is 8).</p>"},{"location":"python/api/#celldega.pre.make_trx_tiles--returns","title":"Returns","text":"<p>dict     A dictionary containing the bounds of the processed data in both x and y directions.</p> Source code in <code>src/celldega/pre/trx_tile.py</code> <pre><code>def make_trx_tiles(\n    technology,\n    path_trx,\n    path_transformation_matrix,\n    path_trx_tiles,\n    coarse_tile_factor=10,\n    tile_size=250,\n    chunk_size=1000000,\n    verbose=False,\n    image_scale=1,\n    max_workers=8\n):\n    \"\"\"\n    Processes transcript data by dividing it into coarse-grain and fine-grain tiles,\n    applying transformations, and saving the results in a parallelized manner.\n\n    Parameters\n    ----------\n    technology : str\n        The technology used for generating the transcript data (e.g., \"MERSCOPE\" or \"Xenium\").\n    path_trx : str\n        Path to the file containing the transcript data.\n    path_transformation_matrix : str\n        Path to the file containing the transformation matrix (CSV file).\n    path_trx_tiles : str\n        Directory path where the output files (Parquet files) for each tile will be saved.\n    coarse_tile_factor : int, optional\n        Scaling factor of each coarse-grain tile comparing to the fine tile size.\n    tile_size : int, optional\n        Size of each fine-grain tile in microns (default is 250).\n    chunk_size : int, optional\n        Number of rows to process per chunk for memory efficiency (default is 1000000).\n    verbose : bool, optional\n        Flag to enable verbose output (default is False).\n    image_scale : float, optional\n        Scale factor to apply to the transcript coordinates (default is 0.5).\n    max_workers : int, optional\n        Maximum number of parallel workers for processing tiles (default is 8).\n\n    Returns\n    -------\n    dict\n        A dictionary containing the bounds of the processed data in both x and y directions.\n    \"\"\"\n\n    def process_coarse_tile(trx, i, j, coarse_tile_x_min, coarse_tile_x_max, coarse_tile_y_min, coarse_tile_y_max, tile_size, path_trx_tiles, x_min, y_min, n_fine_tiles_x, n_fine_tiles_y, max_workers):\n        # Filter the entire dataset for the current coarse tile\n        coarse_tile = trx.filter(\n            (pl.col(\"transformed_x\") &gt;= coarse_tile_x_min) &amp; (pl.col(\"transformed_x\") &lt; coarse_tile_x_max) &amp;\n            (pl.col(\"transformed_y\") &gt;= coarse_tile_y_min) &amp; (pl.col(\"transformed_y\") &lt; coarse_tile_y_max)\n        )\n\n        if not coarse_tile.is_empty():\n            # Now process fine tiles using global fine tile indices\n            process_fine_tiles(coarse_tile, i, j, coarse_tile_x_min, coarse_tile_x_max, coarse_tile_y_min, coarse_tile_y_max, tile_size, path_trx_tiles, x_min, y_min, n_fine_tiles_x, n_fine_tiles_y, max_workers)   \n\n\n    def process_fine_tiles(coarse_tile, coarse_i, coarse_j, coarse_tile_x_min, coarse_tile_x_max, coarse_tile_y_min, coarse_tile_y_max, tile_size, path_trx_tiles, x_min, y_min, n_fine_tiles_x, n_fine_tiles_y, max_workers=8):\n\n        # Use ThreadPoolExecutor for parallel processing of fine-grain tiles within the coarse tile\n        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:\n            futures = []\n\n            # Iterate over fine-grain tiles within the global bounds\n            for fine_i in range(n_fine_tiles_x):\n                fine_tile_x_min = x_min + fine_i * tile_size\n                fine_tile_x_max = fine_tile_x_min + tile_size\n\n                # Process only if the fine tile falls within the current coarse tile's bounds\n                if not (fine_tile_x_min &gt;= coarse_tile_x_min and fine_tile_x_max &lt;= coarse_tile_x_max):\n                    continue\n\n                for fine_j in range(n_fine_tiles_y):\n                    fine_tile_y_min = y_min + fine_j * tile_size\n                    fine_tile_y_max = fine_tile_y_min + tile_size\n\n                    # Process only if the fine tile falls within the current coarse tile's bounds\n                    if not (fine_tile_y_min &gt;= coarse_tile_y_min and fine_tile_y_max &lt;= coarse_tile_y_max):\n                        continue\n\n                    # Submit the task for each fine tile to process in parallel\n                    futures.append(executor.submit(\n                        filter_and_save_fine_tile, coarse_tile, coarse_i, coarse_j, fine_i, fine_j, \n                        fine_tile_x_min, fine_tile_x_max, fine_tile_y_min, fine_tile_y_max, path_trx_tiles\n                    ))\n\n            # Wait for all futures to complete\n            for future in concurrent.futures.as_completed(futures):\n                future.result()  # Raise exceptions if any occurred during execution\n\n\n    def filter_and_save_fine_tile(coarse_tile, coarse_i, coarse_j, fine_i, fine_j, fine_tile_x_min, fine_tile_x_max, fine_tile_y_min, fine_tile_y_max, path_trx_tiles):\n\n        # Filter the coarse tile for the current fine tile's boundaries\n        fine_tile_trx = coarse_tile.filter(\n            (pl.col(\"transformed_x\") &gt;= fine_tile_x_min) &amp; (pl.col(\"transformed_x\") &lt; fine_tile_x_max) &amp;\n            (pl.col(\"transformed_y\") &gt;= fine_tile_y_min) &amp; (pl.col(\"transformed_y\") &lt; fine_tile_y_max)\n        )\n\n        if not fine_tile_trx.is_empty():\n            # Add geometry column as a list of [x, y] pairs\n            fine_tile_trx = fine_tile_trx.with_columns(\n                pl.concat_list([pl.col(\"transformed_x\"), pl.col(\"transformed_y\")]).alias(\"geometry\")\n            ).drop(['transformed_x', 'transformed_y'])\n\n            # Define the filename based on fine tile coordinates\n            filename = f\"{path_trx_tiles}/transcripts_tile_{fine_i}_{fine_j}.parquet\"\n\n            # Save the filtered DataFrame to a Parquet file\n            fine_tile_trx.to_pandas().to_parquet(filename)\n\n\n    # Load transformation matrix\n    transformation_matrix = np.loadtxt(path_transformation_matrix)\n\n    # Load the transcript data based on the technology using Polars\n    if technology == \"MERSCOPE\":\n        trx_ini = pl.read_csv(path_trx, columns=[\"gene\", \"global_x\", \"global_y\"])\n        trx_ini = trx_ini.with_columns([\n            pl.col(\"global_x\").alias(\"x\"),\n            pl.col(\"global_y\").alias(\"y\"),\n            pl.col(\"gene\").alias(\"name\")\n        ]).select([\"name\", \"x\", \"y\"])\n\n    elif technology == \"Xenium\":\n        trx_ini = pl.read_parquet(path_trx).select([\n            pl.col(\"feature_name\").alias(\"name\"),\n            pl.col(\"x_location\").alias(\"x\"),\n            pl.col(\"y_location\").alias(\"y\")\n        ])\n\n    # Process the data in chunks and apply transformations\n    all_chunks = []\n\n    for start_row in tqdm(range(0, trx_ini.height, chunk_size), desc=\"Processing chunks\"):\n        chunk = trx_ini.slice(start_row, chunk_size)\n\n        # Apply transformation matrix to the coordinates\n        points = np.hstack([chunk.select([\"x\", \"y\"]).to_numpy(), np.ones((chunk.height, 1))])\n        transformed_points = np.dot(points, transformation_matrix.T)[:, :2]\n\n        # Create new transformed columns and drop original x, y columns\n        transformed_chunk = chunk.with_columns([\n            (pl.Series(transformed_points[:, 0]) * image_scale).round(2).alias(\"transformed_x\"),\n            (pl.Series(transformed_points[:, 1]) * image_scale).round(2).alias(\"transformed_y\")\n        ]).drop([\"x\", \"y\"])\n        all_chunks.append(transformed_chunk)\n\n    # Concatenate all chunks after processing\n    trx = pl.concat(all_chunks)\n\n    # Ensure the output directory exists\n    if not os.path.exists(path_trx_tiles):\n        os.makedirs(path_trx_tiles)\n\n    # Get min and max x, y values\n    x_min, x_max = trx.select([\n        pl.col(\"transformed_x\").min().alias(\"x_min\"),\n        pl.col(\"transformed_x\").max().alias(\"x_max\")\n    ]).row(0)\n\n    y_min, y_max = trx.select([\n        pl.col(\"transformed_y\").min().alias(\"y_min\"),\n        pl.col(\"transformed_y\").max().alias(\"y_max\")\n    ]).row(0)\n\n    # Calculate the number of fine-grain tiles globally\n    n_fine_tiles_x = int(np.ceil((x_max - x_min) / tile_size))\n    n_fine_tiles_y = int(np.ceil((y_max - y_min) / tile_size))\n\n    # Calculate the number of coarse-grain tiles\n    n_coarse_tiles_x = int(np.ceil((x_max - x_min) / (coarse_tile_factor * tile_size)))\n    n_coarse_tiles_y = int(np.ceil((y_max - y_min) / (coarse_tile_factor * tile_size)))\n\n    # Use ThreadPoolExecutor for parallel processing of coarse-grain tiles\n    with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:\n        futures = []\n        for i in range(n_coarse_tiles_x):\n            coarse_tile_x_min = x_min + i * (coarse_tile_factor * tile_size)\n            coarse_tile_x_max = coarse_tile_x_min + (coarse_tile_factor * tile_size)\n\n            for j in range(n_coarse_tiles_y):\n                coarse_tile_y_min = y_min + j * (coarse_tile_factor * tile_size)\n                coarse_tile_y_max = coarse_tile_y_min + (coarse_tile_factor * tile_size)\n\n                # Submit each coarse tile for parallel processing\n                futures.append(executor.submit(\n                    process_coarse_tile, trx, i, j, coarse_tile_x_min, coarse_tile_x_max, coarse_tile_y_min, coarse_tile_y_max, tile_size, path_trx_tiles, x_min, y_min, n_fine_tiles_x, n_fine_tiles_y, max_workers\n                ))\n\n        # Wait for all coarse tiles to complete\n        for future in tqdm(concurrent.futures.as_completed(futures), desc=\"Processing coarse tiles\", unit=\"tile\"):\n            future.result()  # Raise exceptions if any occurred during execution\n\n    # Return the tile bounds\n    tile_bounds = {\n        \"x_min\": x_min,\n        \"x_max\": x_max,\n        \"y_min\": y_min,\n        \"y_max\": y_max,\n    }\n\n    return tile_bounds\n</code></pre>"},{"location":"python/api/#celldega.pre.read_cbg_mtx","title":"<code>read_cbg_mtx(base_path)</code>","text":"<p>Read the cell-by-gene matrix from the mtx files.</p>"},{"location":"python/api/#celldega.pre.read_cbg_mtx--parameters","title":"Parameters","text":"<p>base_path : str     The base path to the directory containing the mtx files.</p>"},{"location":"python/api/#celldega.pre.read_cbg_mtx--returns","title":"Returns","text":"<p>cbg : pandas.DataFrame     A sparse DataFrame with genes as columns and barcodes as rows.</p> Source code in <code>src/celldega/pre/landscape.py</code> <pre><code>def read_cbg_mtx(base_path):\n    \"\"\"\n    Read the cell-by-gene matrix from the mtx files.\n\n    Parameters\n    ----------\n    base_path : str\n        The base path to the directory containing the mtx files.\n\n    Returns\n    -------\n    cbg : pandas.DataFrame\n        A sparse DataFrame with genes as columns and barcodes as rows.\n    \"\"\"\n    print(\"Reading mtx file from \", base_path)\n\n    # File paths\n    barcodes_path = os.path.join(base_path, \"barcodes.tsv.gz\")\n    features_path = os.path.join(base_path, \"features.tsv.gz\")\n    matrix_path = os.path.join(base_path, \"matrix.mtx.gz\")\n\n    # Read barcodes and features\n    barcodes = pd.read_csv(barcodes_path, header=None, compression=\"gzip\")\n    features = pd.read_csv(features_path, header=None, compression=\"gzip\", sep=\"\\t\")\n\n    # Read the gene expression matrix and transpose it\n    # Transpose and convert to CSC format for fast column slicing\n    matrix = mmread(matrix_path).transpose().tocsc()\n\n    # Create a sparse DataFrame with genes as columns and barcodes as rows\n    cbg = pd.DataFrame.sparse.from_spmatrix(\n        matrix, index=barcodes[0], columns=features[1]\n    )\n    cbg = cbg.rename_axis('__index_level_0__', axis='columns')\n\n    return cbg\n</code></pre>"},{"location":"python/api/#celldega.pre.reduce_image_size","title":"<code>reduce_image_size(image_path, scale_image=0.5, path_landscape_files='')</code>","text":""},{"location":"python/api/#celldega.pre.reduce_image_size--parameters","title":"Parameters","text":"<p>image_path : str     Path to the image file scale_image : float (default=0.5)     Scale factor for the image resize</p>"},{"location":"python/api/#celldega.pre.reduce_image_size--returns","title":"Returns","text":"<p>new_image_path : str     Path to the resized image file</p> Source code in <code>src/celldega/pre/__init__.py</code> <pre><code>def reduce_image_size(image_path, scale_image=0.5, path_landscape_files=\"\"):\n    \"\"\"\n\n    Parameters\n    ----------\n    image_path : str\n        Path to the image file\n    scale_image : float (default=0.5)\n        Scale factor for the image resize\n\n    Returns\n    -------\n    new_image_path : str\n        Path to the resized image file\n    \"\"\"\n\n    image = pyvips.Image.new_from_file(image_path, access=\"sequential\")\n\n    resized_image = image.resize(scale_image)\n\n    new_image_name = image_path.split(\"/\")[-1].replace(\".tif\", \"_downsize.tif\")\n    new_image_path = f\"{path_landscape_files}/{new_image_name}\"\n    resized_image.write_to_file(new_image_path)\n\n    return new_image_path\n</code></pre>"},{"location":"python/api/#celldega.pre.save_cbg_gene_parquets","title":"<code>save_cbg_gene_parquets(base_path, cbg, verbose=False)</code>","text":"<p>Save the cell-by-gene matrix as gene-specific Parquet files.</p>"},{"location":"python/api/#celldega.pre.save_cbg_gene_parquets--parameters","title":"Parameters","text":"<p>base_path : str     The base path to the parent directory containing the landscape_files directory. cbg : pandas.DataFrame     A sparse DataFrame with genes as columns and barcodes as rows. verbose : bool, optional     Whether to print progress information, by default False.</p>"},{"location":"python/api/#celldega.pre.save_cbg_gene_parquets--returns","title":"Returns","text":"<p>None</p> Source code in <code>src/celldega/pre/landscape.py</code> <pre><code>def save_cbg_gene_parquets(base_path, cbg, verbose=False):\n    \"\"\"\n    Save the cell-by-gene matrix as gene-specific Parquet files.\n\n    Parameters\n    ----------\n    base_path : str\n        The base path to the parent directory containing the landscape_files directory.\n    cbg : pandas.DataFrame\n        A sparse DataFrame with genes as columns and barcodes as rows.\n    verbose : bool, optional\n        Whether to print progress information, by default False.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    output_dir = os.path.join(base_path, \"cbg\")\n    os.makedirs(output_dir, exist_ok=True)\n\n    for index, gene in enumerate(cbg.columns):\n        if verbose and index % 100 == 0:\n            print(f\"Processing gene {index}: {gene}\")\n\n        # Extract the column as a DataFrame as a copy\n        col_df = cbg[[gene]].copy()\n\n        # Convert to dense and integer type\n        col_df = col_df.sparse.to_dense().astype(int)\n\n        # Create a DataFrame necessary to prevent error in to_parquet\n        inst_df = pd.DataFrame(\n            col_df.values, columns=[gene], index=col_df.index.tolist()\n        )\n\n        # Replace 0 with NA and drop rows where all values are NA\n        inst_df.replace(0, pd.NA, inplace=True)\n        inst_df.dropna(how=\"all\", inplace=True)\n\n        # Save to Parquet if DataFrame is not empty\n        if not inst_df.empty:\n            output_path = os.path.join(output_dir, f\"{gene}.parquet\")\n            inst_df.to_parquet(output_path)\n</code></pre>"},{"location":"python/api/#celldega.pre.save_landscape_parameters","title":"<code>save_landscape_parameters(technology, path_landscape_files, image_name='dapi_files', tile_size=1000, image_info={}, image_format='.webp')</code>","text":"<p>Save the landscape parameters to a JSON file.</p> Source code in <code>src/celldega/pre/__init__.py</code> <pre><code>def save_landscape_parameters(\n    technology, path_landscape_files, image_name=\"dapi_files\", tile_size=1000, image_info={}, image_format='.webp'\n):\n    \"\"\"\n    Save the landscape parameters to a JSON file.\n    \"\"\"\n\n    path_image_pyramid = f\"{path_landscape_files}/pyramid_images/{image_name}\"\n\n    print(path_image_pyramid)\n\n    max_pyramid_zoom = get_max_zoom_level(path_image_pyramid)\n\n    landscape_parameters = {\n        \"technology\": technology,\n        \"max_pyramid_zoom\": max_pyramid_zoom,\n        \"tile_size\": tile_size,\n        \"image_info\": image_info,\n        \"image_format\": image_format\n    }\n\n    path_landscape_parameters = f\"{path_landscape_files}/landscape_parameters.json\"\n\n    with open(path_landscape_parameters, \"w\") as file:\n        json.dump(landscape_parameters, file, indent=4)\n</code></pre>"},{"location":"python/api/#celldega.viz.Landscape","title":"<code>Landscape</code>","text":"<p>               Bases: <code>AnyWidget</code></p> <p>A widget for interactive visualization of spatial omics data. This widget currently supports iST (Xenium and MERSCOPE) and sST (Visium HD data)</p> <p>Parameters:</p> Name Type Description Default <code>ini_x</code> <code>float</code> <p>The initial x-coordinate of the view.</p> required <code>ini_y</code> <code>float</code> <p>The initial y-coordinate of the view.</p> required <code>ini_zoom</code> <code>float</code> <p>The initial zoom level of the view.</p> required <code>token</code> <code>str</code> <p>The token traitlet.</p> required <code>base_url</code> <code>str</code> <p>The base URL for the widget.</p> required <code>dataset_name</code> <code>str</code> <p>The name of the dataset to visualize. This will show up in the user interface bar.</p> required <p>Attributes:</p> Name Type Description <code>component</code> <code>str</code> <p>The name of the component.</p> <code>technology</code> <code>str</code> <p>The technology used.</p> <code>base_url</code> <code>str</code> <p>The base URL for the widget.</p> <code>token</code> <code>str</code> <p>The token traitlet.</p> <code>ini_x</code> <code>float</code> <p>The initial x-coordinate of the view.</p> <code>ini_y</code> <code>float</code> <p>The initial y-coordinate of the view.</p> <code>ini_z</code> <code>float</code> <p>The initial z-coordinate of the view.</p> <code>ini_zoom</code> <code>float</code> <p>The initial zoom level of the view.</p> <code>dataset_name</code> <code>str</code> <p>The name of the dataset to visualize.</p> <code>update_trigger</code> <code>dict</code> <p>The dictionary to trigger updates.</p> <code>cell_clusters</code> <code>dict</code> <p>The dictionary containing cell cluster information.</p> <p>Returns:</p> Name Type Description <code>Landscape</code> <p>A widget for visualizing a 'landscape' view of spatial omics data.</p> Source code in <code>src/celldega/viz/widget.py</code> <pre><code>class Landscape(anywidget.AnyWidget):\n    \"\"\"\n    A widget for interactive visualization of spatial omics data. This widget\n    currently supports iST (Xenium and MERSCOPE) and sST (Visium HD data)\n\n    Args:\n        ini_x (float): The initial x-coordinate of the view.\n        ini_y (float): The initial y-coordinate of the view.\n        ini_zoom (float): The initial zoom level of the view.\n        token (str): The token traitlet.\n        base_url (str): The base URL for the widget.\n        dataset_name (str, optional): The name of the dataset to visualize. This will show up in the user interface bar.\n\n    Attributes:\n        component (str): The name of the component.\n        technology (str): The technology used.\n        base_url (str): The base URL for the widget.\n        token (str): The token traitlet.\n        ini_x (float): The initial x-coordinate of the view.\n        ini_y (float): The initial y-coordinate of the view.\n        ini_z (float): The initial z-coordinate of the view.\n        ini_zoom (float): The initial zoom level of the view.\n        dataset_name (str): The name of the dataset to visualize.\n        update_trigger (dict): The dictionary to trigger updates.\n        cell_clusters (dict): The dictionary containing cell cluster information.\n\n    Returns:\n        Landscape: A widget for visualizing a 'landscape' view of spatial omics data.\n    \"\"\"\n    _esm = pathlib.Path(__file__).parent / \"../static\" / \"widget.js\"\n    _css = pathlib.Path(__file__).parent / \"../static\" / \"widget.css\"\n    component = traitlets.Unicode(\"Landscape\").tag(sync=True)\n\n    technology = traitlets.Unicode(\"sst\").tag(sync=True)\n    base_url = traitlets.Unicode(\"\").tag(sync=True)\n    token = traitlets.Unicode(\"\").tag(sync=True)\n    ini_x = traitlets.Float(1000).tag(sync=True)\n    ini_y = traitlets.Float(1000).tag(sync=True)\n    ini_z = traitlets.Float(0).tag(sync=True)\n    ini_zoom = traitlets.Float(0).tag(sync=True)\n    square_tile_size = traitlets.Float(1.4).tag(sync=True)\n    dataset_name = traitlets.Unicode(\"\").tag(sync=True)\n    region = traitlets.Dict({}).tag(sync=True)\n    nbhd = traitlets.Dict({}).tag(sync=True)\n\n    update_trigger = traitlets.Dict().tag(sync=True)\n    cell_clusters = traitlets.Dict().tag(sync=True)\n\n    width = traitlets.Int(0).tag(sync=True)\n    height = traitlets.Int(800).tag(sync=True)\n\n    def trigger_update(self, new_value):\n        # This method updates the update_trigger traitlet with a new value\n        # You can pass any information necessary for the update, or just a timestamp\n        self.update_trigger = new_value\n\n    def update_cell_clusters(self, new_clusters):\n        # Convert the new_clusters to a JSON serializable format if necessary\n        self.cell_clusters = new_clusters\n</code></pre>"},{"location":"python/api/#celldega.viz.Matrix","title":"<code>Matrix</code>","text":"<p>               Bases: <code>AnyWidget</code></p> <p>A widget for interactive visualization of a hierarchically clustered matrix.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The value traitlet.</p> required <code>component</code> <code>str</code> <p>The component traitlet.</p> required <code>network</code> <code>dict</code> <p>The network traitlet.</p> required <code>click_info</code> <code>dict</code> <p>The click_info traitlet.</p> required <p>Attributes:</p> Name Type Description <code>component</code> <code>str</code> <p>The name of the component.</p> <code>network</code> <code>dict</code> <p>The network dictionary.</p> <code>click_info</code> <code>dict</code> <p>The click_info dictionary.</p> <p>Returns:</p> Name Type Description <code>Matrix</code> <p>A widget for visualizing a hierarchically clustered matrix.</p> Source code in <code>src/celldega/viz/widget.py</code> <pre><code>class Matrix(anywidget.AnyWidget):\n    \"\"\"\n    A widget for interactive visualization of a hierarchically clustered matrix.\n\n    Args:\n        value (int): The value traitlet.\n        component (str): The component traitlet.\n        network (dict): The network traitlet.\n        click_info (dict): The click_info traitlet.\n\n    Attributes:\n        component (str): The name of the component.\n        network (dict): The network dictionary.\n        click_info (dict): The click_info dictionary.\n\n    Returns:\n        Matrix: A widget for visualizing a hierarchically clustered matrix.\n    \"\"\"\n    _esm = pathlib.Path(__file__).parent / \"../static\" / \"widget.js\"\n    _css = pathlib.Path(__file__).parent / \"../static\" / \"widget.css\"\n    value = traitlets.Int(0).tag(sync=True)\n    component = traitlets.Unicode(\"Matrix\").tag(sync=True)\n\n    network = traitlets.Dict({}).tag(sync=True)\n    width = traitlets.Int(600).tag(sync=True)\n    height = traitlets.Int(600).tag(sync=True)\n    click_info = traitlets.Dict({}).tag(sync=True)\n</code></pre>"},{"location":"python/nbhd/api/","title":"Neighborhood Module API Reference","text":""},{"location":"python/nbhd/api/#celldega.nbhd.alpha_shape_cell_clusters","title":"<code>alpha_shape_cell_clusters(meta_cell, cat='cluster', alphas=[100, 150, 200, 250, 300, 350])</code>","text":"<p>Compute alpha shapes for each cluster in the cell metadata.</p> <p>Parameters: - meta_cell: GeoDataFrame of cell metadata. - cat: Column name in meta_cell containing the cluster labels. - alphas: List of alpha values to compute shapes for.</p> <p>Returns: - GeoDataFrame of alpha shapes.</p> Source code in <code>src/celldega/nbhd/__init__.py</code> <pre><code>def alpha_shape_cell_clusters(meta_cell, cat='cluster', alphas=[100, 150, 200, 250, 300, 350]):\n\n    \"\"\"\n    Compute alpha shapes for each cluster in the cell metadata.\n\n    Parameters:\n    - meta_cell: GeoDataFrame of cell metadata.\n    - cat: Column name in meta_cell containing the cluster labels.\n    - alphas: List of alpha values to compute shapes for.\n\n    Returns:\n    - GeoDataFrame of alpha shapes.\n\n    \"\"\"\n\n    gdf_alpha = gpd.GeoDataFrame()\n\n    for inv_alpha in alphas:\n\n        for inst_cluster in meta_cell[cat].unique():\n\n            inst_clust = meta_cell[meta_cell[cat] == inst_cluster]\n\n            if inst_clust.shape[0]&gt; 3:\n\n                nested_array = inst_clust['geometry'].values\n\n                # Convert to a 2D NumPy array\n                flat_array = np.vstack(nested_array)\n\n                inst_shape = alpha_shape(flat_array, inv_alpha)\n\n                inst_name = inst_cluster + '_' + str(inv_alpha)\n\n                gdf_alpha.loc[inst_name, 'name'] = inst_name\n\n                gdf_alpha.loc[inst_name, 'cat'] = inst_cluster\n\n                gdf_alpha.loc[inst_name, 'geometry'] = inst_shape\n\n                gdf_alpha.loc[inst_name, 'inv_alpha'] = int(inv_alpha)\n\n    gdf_alpha[\"geometry\"] = gdf_alpha[\"geometry\"].apply(lambda geom: _round_coordinates(geom, precision=2))\n\n    gdf_alpha['area'] = gdf_alpha.area\n\n    gdf_alpha = gdf_alpha.loc[gdf_alpha.area.sort_values(ascending=False).index.tolist()]\n\n    return gdf_alpha\n</code></pre>"},{"location":"python/pre/api/","title":"Pre Module API Reference","text":"<p>Module for pre-processing to generate LandscapeFiles from ST data.</p>"},{"location":"python/pre/api/#celldega.pre.calc_meta_gene_data","title":"<code>calc_meta_gene_data(cbg)</code>","text":"<p>Calculate gene metadata from the cell-by-gene matrix</p> <p>Parameters:</p> Name Type Description Default <code>cbg</code> <code>DataFrame</code> <p>A sparse DataFrame with genes as columns and barcodes as rows.</p> required <p>Returns:</p> Type Description <p>pandas.DataFrame: A DataFrame with gene metadata including mean, standard deviation, maximum expression, and proportion of non-zero expression.</p> Source code in <code>src/celldega/pre/landscape.py</code> <pre><code>def calc_meta_gene_data(cbg):\n    \"\"\"\n    Calculate gene metadata from the cell-by-gene matrix\n\n    Args:\n        cbg (pandas.DataFrame): A sparse DataFrame with genes as columns and barcodes as rows.\n\n    Returns:\n        pandas.DataFrame: A DataFrame with gene metadata including mean, standard deviation,\n            maximum expression, and proportion of non-zero expression.\n    \"\"\"\n\n    # Helper function to convert to dense if sparse\n    def convert_to_dense(series):\n        \"\"\"\n        Convert a pandas Series to dense format if it's sparse.\n\n        Parameters\n        ----------\n        series : pandas.Series\n\n        Returns\n        -------\n        pandas.Series\n            Dense Series if input was sparse; original Series otherwise.\n        \"\"\"\n        if pd.api.types.is_sparse(series):\n            return series.sparse.to_dense()\n        return series\n\n    # Ensure cbg is a DataFrame\n    if not isinstance(cbg, pd.DataFrame):\n        raise TypeError(\"cbg must be a pandas DataFrame\")\n\n    # Determine if cbg is sparse\n    is_sparse = pd.api.types.is_sparse(cbg)\n\n    if is_sparse:\n        # Ensure cbg has SparseDtype with float and fill_value=0\n        cbg = cbg.astype(pd.SparseDtype(\"float\", fill_value=0))\n        print(\"cbg is a sparse DataFrame. Proceeding with sparse operations.\")\n    else:\n        print(\"cbg is a dense DataFrame. Proceeding with dense operations.\")\n\n    # Calculate mean expression across tiles\n    print(\"Calculating mean expression\")\n    mean_expression = cbg.mean(axis=0)\n\n    # Calculate variance as the average of the squared deviations\n    print(\"Calculating variance\")\n    num_tiles = cbg.shape[1]\n    variance = cbg.apply(\n        lambda x: ((x - mean_expression[x.name]) ** 2).sum() / num_tiles, axis=0\n    )\n    std_deviation = np.sqrt(variance)\n\n    # Calculate maximum expression\n    max_expression = cbg.max(axis=0)\n\n    # Calculate proportion of tiles with non-zero expression\n    proportion_nonzero = (cbg != 0).sum(axis=0) / len(cbg)\n\n    # Create a DataFrame to hold all these metrics\n    meta_gene = pd.DataFrame(\n        {\n            \"mean\": mean_expression.sparse.to_dense(),\n            \"std\": std_deviation,\n            \"max\": max_expression.sparse.to_dense(),\n            \"non-zero\": proportion_nonzero.sparse.to_dense(),\n        }\n\n    )\n\n    meta_gene_clean = pd.DataFrame(meta_gene.values, index=meta_gene.index.tolist(), columns=meta_gene.columns)\n\n    return meta_gene_clean\n</code></pre>"},{"location":"python/pre/api/#celldega.pre.convert_long_id_to_short","title":"<code>convert_long_id_to_short(df)</code>","text":"<p>Converts a column of long integer cell IDs in a DataFrame to a shorter, hash-based representation.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The DataFrame containing the EntityID.</p> required <p>Returns:     pd.DataFrame: The original DataFrame with an additional column named <code>cell_id</code>                   containing the shortened cell IDs.</p> <p>The function applies a SHA-256 hash to each cell ID, encodes the hash using base64, and truncates it to create a shorter identifier that is added as a new column to the DataFrame.</p> Source code in <code>src/celldega/pre/__init__.py</code> <pre><code>def convert_long_id_to_short(df):\n    \"\"\"\n    Converts a column of long integer cell IDs in a DataFrame to a shorter, hash-based representation.\n\n    Args:\n        df (pd.DataFrame): The DataFrame containing the EntityID.\n    Returns:\n        pd.DataFrame: The original DataFrame with an additional column named `cell_id`\n                      containing the shortened cell IDs.\n\n    The function applies a SHA-256 hash to each cell ID, encodes the hash using base64, and truncates\n    it to create a shorter identifier that is added as a new column to the DataFrame.\n    \"\"\"\n    # Function to hash and encode the cell ID\n    def hash_and_shorten_id(cell_id):\n        # Create a hash of the cell ID\n        cell_id_bytes = str(cell_id).encode('utf-8')\n        hash_object = hashlib.sha256(cell_id_bytes)\n        hash_digest = hash_object.digest()\n\n        # Encode the hash to a base64 string to mix letters and numbers, truncate to 9 characters\n        short_id = base64.urlsafe_b64encode(hash_digest).decode('utf-8')[:9]\n        return short_id\n\n    # Apply the hash_and_shorten_id function to each cell ID in the specified column\n    df['cell_id'] = df['EntityID'].apply(hash_and_shorten_id)\n\n    return df\n</code></pre>"},{"location":"python/pre/api/#celldega.pre.convert_to_jpeg","title":"<code>convert_to_jpeg(image_path, quality=80)</code>","text":"<p>Convert a TIFF image to a JPEG image with a quality of score</p>"},{"location":"python/pre/api/#celldega.pre.convert_to_jpeg--parameters","title":"Parameters","text":"<p>image_path : str     Path to the image file quality : int (default=80)     Quality score for the JPEG image</p>"},{"location":"python/pre/api/#celldega.pre.convert_to_jpeg--returns","title":"Returns","text":"<p>new_image_path : str     Path to the JPEG image file</p> Source code in <code>src/celldega/pre/__init__.py</code> <pre><code>def convert_to_jpeg(image_path, quality=80):\n    \"\"\"\n    Convert a TIFF image to a JPEG image with a quality of score\n\n    Parameters\n    ----------\n    image_path : str\n        Path to the image file\n    quality : int (default=80)\n        Quality score for the JPEG image\n\n    Returns\n    -------\n    new_image_path : str\n        Path to the JPEG image file\n\n    \"\"\"\n\n    # Load the TIFF image\n    image = pyvips.Image.new_from_file(image_path, access=\"sequential\")\n\n    # Save the image as a JPEG with a quality of 80\n    new_image_path = image_path.replace(\".tif\", \".jpeg\")\n    image.jpegsave(new_image_path, Q=quality)\n\n    return new_image_path\n</code></pre>"},{"location":"python/pre/api/#celldega.pre.convert_to_png","title":"<code>convert_to_png(image_path)</code>","text":"<p>Convert a TIFF image to a JPEG image with a quality of score</p>"},{"location":"python/pre/api/#celldega.pre.convert_to_png--parameters","title":"Parameters","text":"<p>image_path : str     Path to the image file quality : int (default=80)     Quality score for the JPEG image</p>"},{"location":"python/pre/api/#celldega.pre.convert_to_png--returns","title":"Returns","text":"<p>new_image_path : str     Path to the JPEG image file</p> Source code in <code>src/celldega/pre/__init__.py</code> <pre><code>def convert_to_png(image_path):\n    \"\"\"\n    Convert a TIFF image to a JPEG image with a quality of score\n\n    Parameters\n    ----------\n    image_path : str\n        Path to the image file\n    quality : int (default=80)\n        Quality score for the JPEG image\n\n    Returns\n    -------\n    new_image_path : str\n        Path to the JPEG image file\n\n    \"\"\"\n\n    # Load the TIFF image\n    image = pyvips.Image.new_from_file(image_path, access=\"sequential\")\n\n    # Save the image as a JPEG with a quality of 80\n    new_image_path = image_path.replace(\".tif\", \".png\")\n    image.pngsave(new_image_path)\n\n    return new_image_path\n</code></pre>"},{"location":"python/pre/api/#celldega.pre.convert_to_webp","title":"<code>convert_to_webp(image_path, quality=100)</code>","text":"<p>Convert a TIFF image to a WEBP image with a specified quality score.</p>"},{"location":"python/pre/api/#celldega.pre.convert_to_webp--parameters","title":"Parameters","text":"<p>image_path : str     Path to the image file quality : int (default=100)     Quality score for the WEBP image (higher is better quality)</p>"},{"location":"python/pre/api/#celldega.pre.convert_to_webp--returns","title":"Returns","text":"<p>new_image_path : str     Path to the WEBP image file</p> Source code in <code>src/celldega/pre/__init__.py</code> <pre><code>def convert_to_webp(image_path, quality=100):\n    \"\"\"\n    Convert a TIFF image to a WEBP image with a specified quality score.\n\n    Parameters\n    ----------\n    image_path : str\n        Path to the image file\n    quality : int (default=100)\n        Quality score for the WEBP image (higher is better quality)\n\n    Returns\n    -------\n    new_image_path : str\n        Path to the WEBP image file\n    \"\"\"\n    # Load the TIFF image\n    image = pyvips.Image.new_from_file(image_path, access=\"sequential\")\n\n    # Save the image as a WEBP with specified quality\n    new_image_path = image_path.replace(\".tif\", \".webp\")\n    image.webpsave(new_image_path, Q=quality)\n\n    return new_image_path\n</code></pre>"},{"location":"python/pre/api/#celldega.pre.get_max_zoom_level","title":"<code>get_max_zoom_level(path_image_pyramid)</code>","text":"<p>Returns the maximum zoom level based on the highest-numbered directory in the specified path_image_pyramid.</p> <p>Parameters:</p> Name Type Description Default <code>path_image_pyramid</code> <code>str</code> <p>The path to the directory containing zoom level directories.</p> required <p>Returns:</p> Name Type Description <code>max_pyramid_zoom</code> <code>int</code> <p>The maximum zoom level.</p> Source code in <code>src/celldega/pre/__init__.py</code> <pre><code>def get_max_zoom_level(path_image_pyramid):\n    \"\"\"\n    Returns the maximum zoom level based on the highest-numbered directory\n    in the specified path_image_pyramid.\n\n    Parameters:\n        path_image_pyramid (str): The path to the directory containing zoom level directories.\n\n    Returns:\n        max_pyramid_zoom (int): The maximum zoom level.\n    \"\"\"\n    # List all entries in the path_image_pyramid that are directories and can be converted to integers\n    zoom_levels = [\n        entry\n        for entry in os.listdir(path_image_pyramid)\n        if os.path.isdir(os.path.join(path_image_pyramid, entry)) and entry.isdigit()\n    ]\n\n    # Convert to integer and find the maximum value\n    max_pyramid_zoom = max(map(int, zoom_levels)) if zoom_levels else None\n\n    return max_pyramid_zoom\n</code></pre>"},{"location":"python/pre/api/#celldega.pre.make_cell_boundary_tiles","title":"<code>make_cell_boundary_tiles(technology, path_cell_boundaries, path_meta_cell_micron, path_transformation_matrix, path_output, coarse_tile_factor=20, tile_size=250, tile_bounds=None, image_scale=1, max_workers=8)</code>","text":"<p>Processes cell boundary data and divides it into spatial tiles based on the provided technology. Reads cell boundary data, applies affine transformations, and divides the data into coarse and fine tiles. The resulting tiles are saved as Parquet files, each containing the geometries of cells in that tile.</p>"},{"location":"python/pre/api/#celldega.pre.make_cell_boundary_tiles--parameters","title":"Parameters","text":"<p>technology : str     The technology used to generate the cell boundary data, e.g., \"MERSCOPE\", \"Xenium\", or \"custom\". path_cell_boundaries : str     Path to the file containing the cell boundaries (Parquet format). path_meta_cell_micron : str     Path to the file containing cell metadata (CSV format). path_transformation_matrix : str     Path to the file containing the transformation matrix (CSV format). path_output : str     Directory path where the output files (Parquet files) for each tile will be saved. coarse_tile_factor  : int, optional, default=20.     scaling factor of each coarse-grain tile comparing to the fine tile size. tile_size : int, optional, default=500     Size of each fine-grain tile in microns. tile_bounds : dict, optional     Dictionary containing the minimum and maximum bounds for x and y coordinates. image_scale : float, optional, default=1     Scale factor to apply to the geometry data. max_workers : int, optional, default=8     Maximum number of parallel workers for processing tiles.</p>"},{"location":"python/pre/api/#celldega.pre.make_cell_boundary_tiles--returns","title":"Returns","text":"<p>None</p> Source code in <code>src/celldega/pre/boundary_tile.py</code> <pre><code>def make_cell_boundary_tiles(\n    technology,\n    path_cell_boundaries,\n    path_meta_cell_micron,\n    path_transformation_matrix,\n    path_output,\n    coarse_tile_factor=20,\n    tile_size=250,\n    tile_bounds=None,\n    image_scale=1,\n    max_workers=8\n):\n\n\n    \"\"\"\n    Processes cell boundary data and divides it into spatial tiles based on the provided technology.\n    Reads cell boundary data, applies affine transformations, and divides the data into coarse and fine tiles.\n    The resulting tiles are saved as Parquet files, each containing the geometries of cells in that tile.\n\n    Parameters\n    ----------\n    technology : str\n        The technology used to generate the cell boundary data, e.g., \"MERSCOPE\", \"Xenium\", or \"custom\".\n    path_cell_boundaries : str\n        Path to the file containing the cell boundaries (Parquet format).\n    path_meta_cell_micron : str\n        Path to the file containing cell metadata (CSV format).\n    path_transformation_matrix : str\n        Path to the file containing the transformation matrix (CSV format).\n    path_output : str\n        Directory path where the output files (Parquet files) for each tile will be saved.\n    coarse_tile_factor  : int, optional, default=20.\n        scaling factor of each coarse-grain tile comparing to the fine tile size.\n    tile_size : int, optional, default=500\n        Size of each fine-grain tile in microns.\n    tile_bounds : dict, optional\n        Dictionary containing the minimum and maximum bounds for x and y coordinates.\n    image_scale : float, optional, default=1\n        Scale factor to apply to the geometry data.\n    max_workers : int, optional, default=8\n        Maximum number of parallel workers for processing tiles.\n\n    Returns\n    -------\n    None\n    \"\"\"\n\n    def numpy_affine_transform(coords, matrix):\n        \"\"\"Apply affine transformation to numpy coordinates.\"\"\"\n        # Homogeneous coordinates for affine transformation\n        coords = np.hstack([coords, np.ones((coords.shape[0], 1))])\n        transformed_coords = coords @ matrix.T\n        return transformed_coords[:, :2]  # Drop the homogeneous coordinate\n\n    def batch_transform_geometries(geometries, transformation_matrix, scale):\n        \"\"\"\n        Batch transform geometries using numpy for optimized performance.\n        \"\"\"\n        # Extract affine transformation parameters into a 3x3 matrix for numpy\n        affine_matrix = np.array([\n            [transformation_matrix[0, 0], transformation_matrix[0, 1], transformation_matrix[0, 2]],\n            [transformation_matrix[1, 0], transformation_matrix[1, 1], transformation_matrix[1, 2]],\n            [0, 0, 1]\n        ])\n\n        transformed_geometries = []\n\n        for polygon in geometries:\n            # Extract coordinates and transform them\n            if isinstance(polygon, MultiPolygon):\n                polygon = next(polygon.geoms)  # Use the first geometry\n\n            # Transform the exterior of the polygon\n            exterior_coords = np.array(polygon.exterior.coords)\n\n            # Apply the affine transformation and scale\n            transformed_coords = numpy_affine_transform(exterior_coords, affine_matrix) / scale\n\n            # Append the result to the transformed_geometries list\n            transformed_geometries.append([transformed_coords.tolist()])\n\n        return transformed_geometries\n\n\n    def filter_and_save_fine_boundary(coarse_tile, fine_i, fine_j, fine_tile_x_min, fine_tile_x_max, fine_tile_y_min, fine_tile_y_max, path_output):\n        cell_ids = coarse_tile.index.values\n\n        tile_filter = (\n            (coarse_tile[\"center_x\"] &gt;= fine_tile_x_min) &amp; (coarse_tile[\"center_x\"] &lt; fine_tile_x_max) &amp;\n            (coarse_tile[\"center_y\"] &gt;= fine_tile_y_min) &amp; (coarse_tile[\"center_y\"] &lt; fine_tile_y_max)\n        )\n        filtered_indices = np.where(tile_filter)[0]\n\n        keep_cells = cell_ids[filtered_indices]\n        fine_tile_cells = coarse_tile.loc[keep_cells, [\"GEOMETRY\"]]\n        fine_tile_cells = fine_tile_cells.assign(name=fine_tile_cells.index)\n\n        if not fine_tile_cells.empty:\n            filename = f\"{path_output}/cell_tile_{fine_i}_{fine_j}.parquet\"\n            fine_tile_cells.to_parquet(filename)\n\n    def process_fine_boundaries(coarse_tile, i, j, coarse_tile_x_min, coarse_tile_x_max, coarse_tile_y_min, coarse_tile_y_max, tile_size, path_output, x_min, y_min, n_fine_tiles_x, n_fine_tiles_y):\n        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:\n            futures = []\n            for fine_i in range(n_fine_tiles_x):\n                fine_tile_x_min = x_min + fine_i * tile_size\n                fine_tile_x_max = fine_tile_x_min + tile_size\n\n                if not (fine_tile_x_min &gt;= coarse_tile_x_min and fine_tile_x_max &lt;= coarse_tile_x_max):\n                    continue\n\n                for fine_j in range(n_fine_tiles_y):\n                    fine_tile_y_min = y_min + fine_j * tile_size\n                    fine_tile_y_max = fine_tile_y_min + tile_size\n\n                    if not (fine_tile_y_min &gt;= coarse_tile_y_min and fine_tile_y_max &lt;= coarse_tile_y_max):\n                        continue\n\n                    futures.append(executor.submit(\n                        filter_and_save_fine_boundary, coarse_tile, fine_i, fine_j, fine_tile_x_min, fine_tile_x_max, fine_tile_y_min, fine_tile_y_max, path_output\n                    ))\n\n            for future in futures:\n                future.result()\n\n    tile_size_x = tile_size\n    tile_size_y = tile_size\n\n    transformation_matrix = pd.read_csv(path_transformation_matrix, header=None, sep=\" \").values\n\n    # Load cell boundary data based on the technology\n    if technology == \"MERSCOPE\":\n        df_meta = pd.read_parquet(f\"{path_output.replace('cell_segmentation','cell_metadata.parquet')}\")\n        entity_to_cell_id_dict = pd.Series(df_meta.index.values, index=df_meta.EntityID).to_dict()\n        cells_orig = gpd.read_parquet(path_cell_boundaries)\n        cells_orig['cell_id'] = cells_orig['EntityID'].map(entity_to_cell_id_dict)\n        cells_orig = cells_orig[cells_orig[\"ZIndex\"] == 1]\n\n        # Correct cell_id issues with meta_cell\n        meta_cell = pd.read_csv(path_meta_cell_micron)\n        meta_cell['cell_id'] = meta_cell['EntityID'].map(entity_to_cell_id_dict)\n        cells_orig.index = meta_cell[meta_cell[\"cell_id\"].isin(cells_orig['cell_id'])].index\n\n        # Correct 'MultiPolygon' to 'Polygon'\n        cells_orig[\"geometry\"] = cells_orig[\"Geometry\"].apply(\n            lambda x: list(x.geoms)[0] if isinstance(x, MultiPolygon) else x\n        )\n\n        cells_orig.set_index('cell_id', inplace=True)\n\n    elif technology == \"Xenium\":\n        xenium_cells = pd.read_parquet(path_cell_boundaries)\n        grouped = xenium_cells.groupby(\"cell_id\")[[\"vertex_x\", \"vertex_y\"]].agg(lambda x: x.tolist())\n        grouped[\"geometry\"] = grouped.apply(lambda row: Polygon(zip(row[\"vertex_x\"], row[\"vertex_y\"])), axis=1)\n        cells_orig = gpd.GeoDataFrame(grouped, geometry=\"geometry\")[[\"geometry\"]]\n\n    elif technology == \"custom\":\n        cells_orig = gpd.read_parquet(path_cell_boundaries)\n\n    # Transform geometries\n    cells_orig[\"GEOMETRY\"] = batch_transform_geometries(cells_orig[\"geometry\"], transformation_matrix, image_scale)\n\n    # Convert transformed geometries to polygons and calculate centroids\n    cells_orig[\"polygon\"] = cells_orig[\"GEOMETRY\"].apply(lambda x: Polygon(x[0]))\n    gdf_cells = gpd.GeoDataFrame(geometry=cells_orig[\"polygon\"])\n    gdf_cells[\"center_x\"] = gdf_cells.geometry.centroid.x\n    gdf_cells[\"center_y\"] = gdf_cells.geometry.centroid.y\n    gdf_cells[\"GEOMETRY\"] = cells_orig[\"GEOMETRY\"]\n\n    # Ensure the output directory exists\n    if not os.path.exists(path_output):\n        os.makedirs(path_output)\n\n    # Calculate tile bounds and fine/coarse tiles\n    x_min, x_max = tile_bounds[\"x_min\"], tile_bounds[\"x_max\"]\n    y_min, y_max = tile_bounds[\"y_min\"], tile_bounds[\"y_max\"]\n    n_fine_tiles_x = int(np.ceil((x_max - x_min) / tile_size))\n    n_fine_tiles_y = int(np.ceil((y_max - y_min) / tile_size))\n    n_coarse_tiles_x = int(np.ceil((x_max - x_min) / (coarse_tile_factor * tile_size)))\n    n_coarse_tiles_y = int(np.ceil((y_max - y_min) / (coarse_tile_factor * tile_size)))\n\n    # Process coarse tiles in parallel\n    for i in tqdm(range(n_coarse_tiles_x), desc=\"Processing coarse tiles\"):\n        coarse_tile_x_min = x_min + i * (coarse_tile_factor * tile_size)\n        coarse_tile_x_max = coarse_tile_x_min + (coarse_tile_factor * tile_size)\n\n        for j in range(n_coarse_tiles_y):\n            coarse_tile_y_min = y_min + j * (coarse_tile_factor * tile_size)\n            coarse_tile_y_max = coarse_tile_y_min + (coarse_tile_factor * tile_size)\n\n            coarse_tile = gdf_cells[\n                (gdf_cells[\"center_x\"] &gt;= coarse_tile_x_min) &amp; (gdf_cells[\"center_x\"] &lt; coarse_tile_x_max) &amp;\n                (gdf_cells[\"center_y\"] &gt;= coarse_tile_y_min) &amp; (gdf_cells[\"center_y\"] &lt; coarse_tile_y_max)\n            ]\n            if not coarse_tile.empty:\n                process_fine_boundaries(coarse_tile, i, j, coarse_tile_x_min, coarse_tile_x_max, coarse_tile_y_min, coarse_tile_y_max, tile_size, path_output, x_min, y_min, n_fine_tiles_x, n_fine_tiles_y)\n</code></pre>"},{"location":"python/pre/api/#celldega.pre.make_deepzoom_pyramid","title":"<code>make_deepzoom_pyramid(image_path, output_path, pyramid_name, tile_size=512, overlap=0, suffix='.jpeg')</code>","text":"<p>Create a DeepZoom image pyramid from a JPEG image</p>"},{"location":"python/pre/api/#celldega.pre.make_deepzoom_pyramid--parameters","title":"Parameters","text":"<p>image_path : str     Path to the JPEG image file tile_size : int (default=512)     Tile size for the DeepZoom pyramid overlap : int (default=0)     Overlap size for the DeepZoom pyramid suffix : str (default='jpeg')     Suffix for the DeepZoom pyramid tiles</p>"},{"location":"python/pre/api/#celldega.pre.make_deepzoom_pyramid--returns","title":"Returns","text":"<p>None</p> Source code in <code>src/celldega/pre/__init__.py</code> <pre><code>def make_deepzoom_pyramid(\n    image_path, output_path, pyramid_name, tile_size=512, overlap=0, suffix=\".jpeg\"\n):\n    \"\"\"\n    Create a DeepZoom image pyramid from a JPEG image\n\n    Parameters\n    ----------\n    image_path : str\n        Path to the JPEG image file\n    tile_size : int (default=512)\n        Tile size for the DeepZoom pyramid\n    overlap : int (default=0)\n        Overlap size for the DeepZoom pyramid\n    suffix : str (default='jpeg')\n        Suffix for the DeepZoom pyramid tiles\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n\n    # Define the output path\n    output_path = Path(output_path)\n\n    # Load the JPEG image\n    image = pyvips.Image.new_from_file(image_path, access=\"sequential\")\n\n    # check if the output path exists and create it if it does not\n    output_path.mkdir(parents=True, exist_ok=True)\n\n    # append the pyramid name to the output path\n    output_path = output_path / pyramid_name\n\n    # Save the image as a DeepZoom image pyramid\n    image.dzsave(output_path, tile_size=tile_size, overlap=overlap, suffix=suffix)\n</code></pre>"},{"location":"python/pre/api/#celldega.pre.make_meta_cell_image_coord","title":"<code>make_meta_cell_image_coord(technology, path_transformation_matrix, path_meta_cell_micron, path_meta_cell_image, image_scale)</code>","text":"<p>Apply an affine transformation to the cell coordinates in microns and save the transformed coordinates in pixels</p>"},{"location":"python/pre/api/#celldega.pre.make_meta_cell_image_coord--parameters","title":"Parameters","text":"<p>technology : str     The technology used to generate the data, Xenium and MERSCOPE are supported. path_transformation_matrix : str     Path to the transformation matrix file path_meta_cell_micron : str     Path to the meta cell file with coordinates in microns path_meta_cell_image : str     Path to save the meta cell file with coordinates in pixels</p>"},{"location":"python/pre/api/#celldega.pre.make_meta_cell_image_coord--returns","title":"Returns","text":"<p>None</p>"},{"location":"python/pre/api/#celldega.pre.make_meta_cell_image_coord--examples","title":"Examples","text":"<p>make_meta_cell_image_coord( ...     technology='Xenium', ...     path_transformation_matrix='data/transformation_matrix.txt', ...     path_meta_cell_micron='data/meta_cell_micron.csv', ...     path_meta_cell_image='data/meta_cell_image.parquet' ... )</p> Source code in <code>src/celldega/pre/__init__.py</code> <pre><code>def make_meta_cell_image_coord(\n    technology,\n    path_transformation_matrix,\n    path_meta_cell_micron,\n    path_meta_cell_image,\n    image_scale\n):\n    \"\"\"\n    Apply an affine transformation to the cell coordinates in microns and save\n    the transformed coordinates in pixels\n\n    Parameters\n    ----------\n    technology : str\n        The technology used to generate the data, Xenium and MERSCOPE are supported.\n    path_transformation_matrix : str\n        Path to the transformation matrix file\n    path_meta_cell_micron : str\n        Path to the meta cell file with coordinates in microns\n    path_meta_cell_image : str\n        Path to save the meta cell file with coordinates in pixels\n\n    Returns\n    -------\n    None\n\n    Examples\n    --------\n    &gt;&gt;&gt; make_meta_cell_image_coord(\n    ...     technology='Xenium',\n    ...     path_transformation_matrix='data/transformation_matrix.txt',\n    ...     path_meta_cell_micron='data/meta_cell_micron.csv',\n    ...     path_meta_cell_image='data/meta_cell_image.parquet'\n    ... )\n\n    \"\"\"\n\n    transformation_matrix = pd.read_csv(\n        path_transformation_matrix, header=None, sep=\" \"\n    ).values\n\n    if technology == \"MERSCOPE\":\n        meta_cell = pd.read_csv(path_meta_cell_micron, usecols=[\"EntityID\", \"center_x\", \"center_y\"])\n        meta_cell = convert_long_id_to_short(meta_cell)\n        meta_cell[\"name\"] =  meta_cell[\"cell_id\"]\n        meta_cell = meta_cell.set_index('cell_id')\n    elif technology == \"Xenium\":\n        usecols = [\"cell_id\", \"x_centroid\", \"y_centroid\"]\n        meta_cell = pd.read_csv(path_meta_cell_micron, index_col=0, usecols=usecols)\n        meta_cell.columns = [\"center_x\", \"center_y\"]\n        meta_cell[\"name\"] = pd.Series(meta_cell.index, index=meta_cell.index)\n\n    # Adding a ones column to accommodate for affine transformation\n    meta_cell[\"ones\"] = 1\n\n    # Preparing the data for matrix multiplication\n    points = meta_cell[[\"center_x\", \"center_y\", \"ones\"]].values\n\n    # Applying the transformation matrix\n    transformed_points = np.dot(transformation_matrix, points.T).T\n\n    # Updating the DataFrame with transformed coordinates\n    meta_cell[\"center_x\"] = transformed_points[:, 0]\n    meta_cell[\"center_y\"] = transformed_points[:, 1]\n\n    # Dropping the ones column as it's no longer needed\n    meta_cell.drop(columns=[\"ones\"], inplace=True)\n\n    meta_cell[\"center_x\"] = meta_cell[\"center_x\"] / image_scale\n    meta_cell[\"center_y\"] = meta_cell[\"center_y\"] / image_scale\n\n    meta_cell[\"geometry\"] = meta_cell.apply(\n        lambda row: [row[\"center_x\"], row[\"center_y\"]], axis=1\n    )\n\n    if technology == \"MERSCOPE\":\n        meta_cell = meta_cell[[\"name\", \"geometry\", \"EntityID\"]]\n    else:\n        meta_cell = meta_cell[[\"name\", \"geometry\"]]\n\n\n    meta_cell.to_parquet(path_meta_cell_image)\n</code></pre>"},{"location":"python/pre/api/#celldega.pre.make_meta_gene","title":"<code>make_meta_gene(technology, path_cbg, path_output)</code>","text":"<p>Create a DataFrame with genes and their assigned colors</p>"},{"location":"python/pre/api/#celldega.pre.make_meta_gene--parameters","title":"Parameters","text":"<p>technology : str     The technology used to generate the data, Xenium and MERSCOPE are supported. path_cbg : str     Path to the cell-by-gene matrix data (the data format can vary based on technology) path_output : str     Path to save the meta gene file</p>"},{"location":"python/pre/api/#celldega.pre.make_meta_gene--returns","title":"Returns","text":"<p>None</p>"},{"location":"python/pre/api/#celldega.pre.make_meta_gene--examples","title":"Examples","text":"<p>make_meta_gene( ...     technology='Xenium', ...     path_cbg='data/', ...     path_output='data/meta_gene.parquet' ... )</p> Source code in <code>src/celldega/pre/__init__.py</code> <pre><code>def make_meta_gene(technology, path_cbg, path_output):\n    \"\"\"\n    Create a DataFrame with genes and their assigned colors\n\n    Parameters\n    ----------\n    technology : str\n        The technology used to generate the data, Xenium and MERSCOPE are supported.\n    path_cbg : str\n        Path to the cell-by-gene matrix data (the data format can vary based on technology)\n    path_output : str\n        Path to save the meta gene file\n\n    Returns\n    -------\n    None\n\n    Examples\n    --------\n    &gt;&gt;&gt; make_meta_gene(\n    ...     technology='Xenium',\n    ...     path_cbg='data/',\n    ...     path_output='data/meta_gene.parquet'\n    ... )\n    \"\"\"\n\n    if technology == \"MERSCOPE\":\n        cbg = pd.read_csv(path_cbg, index_col=0)\n        genes = cbg.columns.tolist()\n    elif technology == \"Xenium\":\n        # genes = pd.read_csv(path_cbg + 'features.tsv.gz', sep='\\t', header=None)[1].values.tolist()\n        cbg = read_cbg_mtx(path_cbg)\n        genes = cbg.columns.tolist()\n\n    # Get all categorical color palettes from Matplotlib and flatten them into a single list of colors\n    palettes = [plt.get_cmap(name).colors for name in plt.colormaps() if \"tab\" in name]\n    flat_colors = [color for palette in palettes for color in palette]\n\n    # Convert RGB tuples to hex codes\n    flat_colors_hex = [to_hex(color) for color in flat_colors]\n\n    # Use modular arithmetic to assign a color to each gene, white for genes with \"Blank\"\n    colors = [\n        flat_colors_hex[i % len(flat_colors_hex)] if \"Blank\" not in gene else \"#FFFFFF\"\n        for i, gene in enumerate(genes)\n    ]\n\n    # Create a DataFrame with genes and their assigned colors\n    ser_color = pd.Series(colors, index=genes)\n\n    # calculate gene expression metadata\n    meta_gene = calc_meta_gene_data(cbg)\n    meta_gene['color'] = ser_color\n\n    # Identify sparse columns\n    sparse_cols = [col for col in meta_gene.columns if pd.api.types.is_sparse(meta_gene[col])]\n\n    # Convert sparse columns to dense\n    for col in sparse_cols:\n        meta_gene[col] = meta_gene[col].sparse.to_dense()\n\n    meta_gene.to_parquet(path_output)\n</code></pre>"},{"location":"python/pre/api/#celldega.pre.make_trx_tiles","title":"<code>make_trx_tiles(technology, path_trx, path_transformation_matrix, path_trx_tiles, coarse_tile_factor=10, tile_size=250, chunk_size=1000000, verbose=False, image_scale=1, max_workers=8)</code>","text":"<p>Processes transcript data by dividing it into coarse-grain and fine-grain tiles, applying transformations, and saving the results in a parallelized manner.</p>"},{"location":"python/pre/api/#celldega.pre.make_trx_tiles--parameters","title":"Parameters","text":"<p>technology : str     The technology used for generating the transcript data (e.g., \"MERSCOPE\" or \"Xenium\"). path_trx : str     Path to the file containing the transcript data. path_transformation_matrix : str     Path to the file containing the transformation matrix (CSV file). path_trx_tiles : str     Directory path where the output files (Parquet files) for each tile will be saved. coarse_tile_factor : int, optional     Scaling factor of each coarse-grain tile comparing to the fine tile size. tile_size : int, optional     Size of each fine-grain tile in microns (default is 250). chunk_size : int, optional     Number of rows to process per chunk for memory efficiency (default is 1000000). verbose : bool, optional     Flag to enable verbose output (default is False). image_scale : float, optional     Scale factor to apply to the transcript coordinates (default is 0.5). max_workers : int, optional     Maximum number of parallel workers for processing tiles (default is 8).</p>"},{"location":"python/pre/api/#celldega.pre.make_trx_tiles--returns","title":"Returns","text":"<p>dict     A dictionary containing the bounds of the processed data in both x and y directions.</p> Source code in <code>src/celldega/pre/trx_tile.py</code> <pre><code>def make_trx_tiles(\n    technology,\n    path_trx,\n    path_transformation_matrix,\n    path_trx_tiles,\n    coarse_tile_factor=10,\n    tile_size=250,\n    chunk_size=1000000,\n    verbose=False,\n    image_scale=1,\n    max_workers=8\n):\n    \"\"\"\n    Processes transcript data by dividing it into coarse-grain and fine-grain tiles,\n    applying transformations, and saving the results in a parallelized manner.\n\n    Parameters\n    ----------\n    technology : str\n        The technology used for generating the transcript data (e.g., \"MERSCOPE\" or \"Xenium\").\n    path_trx : str\n        Path to the file containing the transcript data.\n    path_transformation_matrix : str\n        Path to the file containing the transformation matrix (CSV file).\n    path_trx_tiles : str\n        Directory path where the output files (Parquet files) for each tile will be saved.\n    coarse_tile_factor : int, optional\n        Scaling factor of each coarse-grain tile comparing to the fine tile size.\n    tile_size : int, optional\n        Size of each fine-grain tile in microns (default is 250).\n    chunk_size : int, optional\n        Number of rows to process per chunk for memory efficiency (default is 1000000).\n    verbose : bool, optional\n        Flag to enable verbose output (default is False).\n    image_scale : float, optional\n        Scale factor to apply to the transcript coordinates (default is 0.5).\n    max_workers : int, optional\n        Maximum number of parallel workers for processing tiles (default is 8).\n\n    Returns\n    -------\n    dict\n        A dictionary containing the bounds of the processed data in both x and y directions.\n    \"\"\"\n\n    def process_coarse_tile(trx, i, j, coarse_tile_x_min, coarse_tile_x_max, coarse_tile_y_min, coarse_tile_y_max, tile_size, path_trx_tiles, x_min, y_min, n_fine_tiles_x, n_fine_tiles_y, max_workers):\n        # Filter the entire dataset for the current coarse tile\n        coarse_tile = trx.filter(\n            (pl.col(\"transformed_x\") &gt;= coarse_tile_x_min) &amp; (pl.col(\"transformed_x\") &lt; coarse_tile_x_max) &amp;\n            (pl.col(\"transformed_y\") &gt;= coarse_tile_y_min) &amp; (pl.col(\"transformed_y\") &lt; coarse_tile_y_max)\n        )\n\n        if not coarse_tile.is_empty():\n            # Now process fine tiles using global fine tile indices\n            process_fine_tiles(coarse_tile, i, j, coarse_tile_x_min, coarse_tile_x_max, coarse_tile_y_min, coarse_tile_y_max, tile_size, path_trx_tiles, x_min, y_min, n_fine_tiles_x, n_fine_tiles_y, max_workers)   \n\n\n    def process_fine_tiles(coarse_tile, coarse_i, coarse_j, coarse_tile_x_min, coarse_tile_x_max, coarse_tile_y_min, coarse_tile_y_max, tile_size, path_trx_tiles, x_min, y_min, n_fine_tiles_x, n_fine_tiles_y, max_workers=8):\n\n        # Use ThreadPoolExecutor for parallel processing of fine-grain tiles within the coarse tile\n        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:\n            futures = []\n\n            # Iterate over fine-grain tiles within the global bounds\n            for fine_i in range(n_fine_tiles_x):\n                fine_tile_x_min = x_min + fine_i * tile_size\n                fine_tile_x_max = fine_tile_x_min + tile_size\n\n                # Process only if the fine tile falls within the current coarse tile's bounds\n                if not (fine_tile_x_min &gt;= coarse_tile_x_min and fine_tile_x_max &lt;= coarse_tile_x_max):\n                    continue\n\n                for fine_j in range(n_fine_tiles_y):\n                    fine_tile_y_min = y_min + fine_j * tile_size\n                    fine_tile_y_max = fine_tile_y_min + tile_size\n\n                    # Process only if the fine tile falls within the current coarse tile's bounds\n                    if not (fine_tile_y_min &gt;= coarse_tile_y_min and fine_tile_y_max &lt;= coarse_tile_y_max):\n                        continue\n\n                    # Submit the task for each fine tile to process in parallel\n                    futures.append(executor.submit(\n                        filter_and_save_fine_tile, coarse_tile, coarse_i, coarse_j, fine_i, fine_j, \n                        fine_tile_x_min, fine_tile_x_max, fine_tile_y_min, fine_tile_y_max, path_trx_tiles\n                    ))\n\n            # Wait for all futures to complete\n            for future in concurrent.futures.as_completed(futures):\n                future.result()  # Raise exceptions if any occurred during execution\n\n\n    def filter_and_save_fine_tile(coarse_tile, coarse_i, coarse_j, fine_i, fine_j, fine_tile_x_min, fine_tile_x_max, fine_tile_y_min, fine_tile_y_max, path_trx_tiles):\n\n        # Filter the coarse tile for the current fine tile's boundaries\n        fine_tile_trx = coarse_tile.filter(\n            (pl.col(\"transformed_x\") &gt;= fine_tile_x_min) &amp; (pl.col(\"transformed_x\") &lt; fine_tile_x_max) &amp;\n            (pl.col(\"transformed_y\") &gt;= fine_tile_y_min) &amp; (pl.col(\"transformed_y\") &lt; fine_tile_y_max)\n        )\n\n        if not fine_tile_trx.is_empty():\n            # Add geometry column as a list of [x, y] pairs\n            fine_tile_trx = fine_tile_trx.with_columns(\n                pl.concat_list([pl.col(\"transformed_x\"), pl.col(\"transformed_y\")]).alias(\"geometry\")\n            ).drop(['transformed_x', 'transformed_y'])\n\n            # Define the filename based on fine tile coordinates\n            filename = f\"{path_trx_tiles}/transcripts_tile_{fine_i}_{fine_j}.parquet\"\n\n            # Save the filtered DataFrame to a Parquet file\n            fine_tile_trx.to_pandas().to_parquet(filename)\n\n\n    # Load transformation matrix\n    transformation_matrix = np.loadtxt(path_transformation_matrix)\n\n    # Load the transcript data based on the technology using Polars\n    if technology == \"MERSCOPE\":\n        trx_ini = pl.read_csv(path_trx, columns=[\"gene\", \"global_x\", \"global_y\"])\n        trx_ini = trx_ini.with_columns([\n            pl.col(\"global_x\").alias(\"x\"),\n            pl.col(\"global_y\").alias(\"y\"),\n            pl.col(\"gene\").alias(\"name\")\n        ]).select([\"name\", \"x\", \"y\"])\n\n    elif technology == \"Xenium\":\n        trx_ini = pl.read_parquet(path_trx).select([\n            pl.col(\"feature_name\").alias(\"name\"),\n            pl.col(\"x_location\").alias(\"x\"),\n            pl.col(\"y_location\").alias(\"y\")\n        ])\n\n    # Process the data in chunks and apply transformations\n    all_chunks = []\n\n    for start_row in tqdm(range(0, trx_ini.height, chunk_size), desc=\"Processing chunks\"):\n        chunk = trx_ini.slice(start_row, chunk_size)\n\n        # Apply transformation matrix to the coordinates\n        points = np.hstack([chunk.select([\"x\", \"y\"]).to_numpy(), np.ones((chunk.height, 1))])\n        transformed_points = np.dot(points, transformation_matrix.T)[:, :2]\n\n        # Create new transformed columns and drop original x, y columns\n        transformed_chunk = chunk.with_columns([\n            (pl.Series(transformed_points[:, 0]) * image_scale).round(2).alias(\"transformed_x\"),\n            (pl.Series(transformed_points[:, 1]) * image_scale).round(2).alias(\"transformed_y\")\n        ]).drop([\"x\", \"y\"])\n        all_chunks.append(transformed_chunk)\n\n    # Concatenate all chunks after processing\n    trx = pl.concat(all_chunks)\n\n    # Ensure the output directory exists\n    if not os.path.exists(path_trx_tiles):\n        os.makedirs(path_trx_tiles)\n\n    # Get min and max x, y values\n    x_min, x_max = trx.select([\n        pl.col(\"transformed_x\").min().alias(\"x_min\"),\n        pl.col(\"transformed_x\").max().alias(\"x_max\")\n    ]).row(0)\n\n    y_min, y_max = trx.select([\n        pl.col(\"transformed_y\").min().alias(\"y_min\"),\n        pl.col(\"transformed_y\").max().alias(\"y_max\")\n    ]).row(0)\n\n    # Calculate the number of fine-grain tiles globally\n    n_fine_tiles_x = int(np.ceil((x_max - x_min) / tile_size))\n    n_fine_tiles_y = int(np.ceil((y_max - y_min) / tile_size))\n\n    # Calculate the number of coarse-grain tiles\n    n_coarse_tiles_x = int(np.ceil((x_max - x_min) / (coarse_tile_factor * tile_size)))\n    n_coarse_tiles_y = int(np.ceil((y_max - y_min) / (coarse_tile_factor * tile_size)))\n\n    # Use ThreadPoolExecutor for parallel processing of coarse-grain tiles\n    with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:\n        futures = []\n        for i in range(n_coarse_tiles_x):\n            coarse_tile_x_min = x_min + i * (coarse_tile_factor * tile_size)\n            coarse_tile_x_max = coarse_tile_x_min + (coarse_tile_factor * tile_size)\n\n            for j in range(n_coarse_tiles_y):\n                coarse_tile_y_min = y_min + j * (coarse_tile_factor * tile_size)\n                coarse_tile_y_max = coarse_tile_y_min + (coarse_tile_factor * tile_size)\n\n                # Submit each coarse tile for parallel processing\n                futures.append(executor.submit(\n                    process_coarse_tile, trx, i, j, coarse_tile_x_min, coarse_tile_x_max, coarse_tile_y_min, coarse_tile_y_max, tile_size, path_trx_tiles, x_min, y_min, n_fine_tiles_x, n_fine_tiles_y, max_workers\n                ))\n\n        # Wait for all coarse tiles to complete\n        for future in tqdm(concurrent.futures.as_completed(futures), desc=\"Processing coarse tiles\", unit=\"tile\"):\n            future.result()  # Raise exceptions if any occurred during execution\n\n    # Return the tile bounds\n    tile_bounds = {\n        \"x_min\": x_min,\n        \"x_max\": x_max,\n        \"y_min\": y_min,\n        \"y_max\": y_max,\n    }\n\n    return tile_bounds\n</code></pre>"},{"location":"python/pre/api/#celldega.pre.read_cbg_mtx","title":"<code>read_cbg_mtx(base_path)</code>","text":"<p>Read the cell-by-gene matrix from the mtx files.</p>"},{"location":"python/pre/api/#celldega.pre.read_cbg_mtx--parameters","title":"Parameters","text":"<p>base_path : str     The base path to the directory containing the mtx files.</p>"},{"location":"python/pre/api/#celldega.pre.read_cbg_mtx--returns","title":"Returns","text":"<p>cbg : pandas.DataFrame     A sparse DataFrame with genes as columns and barcodes as rows.</p> Source code in <code>src/celldega/pre/landscape.py</code> <pre><code>def read_cbg_mtx(base_path):\n    \"\"\"\n    Read the cell-by-gene matrix from the mtx files.\n\n    Parameters\n    ----------\n    base_path : str\n        The base path to the directory containing the mtx files.\n\n    Returns\n    -------\n    cbg : pandas.DataFrame\n        A sparse DataFrame with genes as columns and barcodes as rows.\n    \"\"\"\n    print(\"Reading mtx file from \", base_path)\n\n    # File paths\n    barcodes_path = os.path.join(base_path, \"barcodes.tsv.gz\")\n    features_path = os.path.join(base_path, \"features.tsv.gz\")\n    matrix_path = os.path.join(base_path, \"matrix.mtx.gz\")\n\n    # Read barcodes and features\n    barcodes = pd.read_csv(barcodes_path, header=None, compression=\"gzip\")\n    features = pd.read_csv(features_path, header=None, compression=\"gzip\", sep=\"\\t\")\n\n    # Read the gene expression matrix and transpose it\n    # Transpose and convert to CSC format for fast column slicing\n    matrix = mmread(matrix_path).transpose().tocsc()\n\n    # Create a sparse DataFrame with genes as columns and barcodes as rows\n    cbg = pd.DataFrame.sparse.from_spmatrix(\n        matrix, index=barcodes[0], columns=features[1]\n    )\n    cbg = cbg.rename_axis('__index_level_0__', axis='columns')\n\n    return cbg\n</code></pre>"},{"location":"python/pre/api/#celldega.pre.reduce_image_size","title":"<code>reduce_image_size(image_path, scale_image=0.5, path_landscape_files='')</code>","text":""},{"location":"python/pre/api/#celldega.pre.reduce_image_size--parameters","title":"Parameters","text":"<p>image_path : str     Path to the image file scale_image : float (default=0.5)     Scale factor for the image resize</p>"},{"location":"python/pre/api/#celldega.pre.reduce_image_size--returns","title":"Returns","text":"<p>new_image_path : str     Path to the resized image file</p> Source code in <code>src/celldega/pre/__init__.py</code> <pre><code>def reduce_image_size(image_path, scale_image=0.5, path_landscape_files=\"\"):\n    \"\"\"\n\n    Parameters\n    ----------\n    image_path : str\n        Path to the image file\n    scale_image : float (default=0.5)\n        Scale factor for the image resize\n\n    Returns\n    -------\n    new_image_path : str\n        Path to the resized image file\n    \"\"\"\n\n    image = pyvips.Image.new_from_file(image_path, access=\"sequential\")\n\n    resized_image = image.resize(scale_image)\n\n    new_image_name = image_path.split(\"/\")[-1].replace(\".tif\", \"_downsize.tif\")\n    new_image_path = f\"{path_landscape_files}/{new_image_name}\"\n    resized_image.write_to_file(new_image_path)\n\n    return new_image_path\n</code></pre>"},{"location":"python/pre/api/#celldega.pre.save_cbg_gene_parquets","title":"<code>save_cbg_gene_parquets(base_path, cbg, verbose=False)</code>","text":"<p>Save the cell-by-gene matrix as gene-specific Parquet files.</p>"},{"location":"python/pre/api/#celldega.pre.save_cbg_gene_parquets--parameters","title":"Parameters","text":"<p>base_path : str     The base path to the parent directory containing the landscape_files directory. cbg : pandas.DataFrame     A sparse DataFrame with genes as columns and barcodes as rows. verbose : bool, optional     Whether to print progress information, by default False.</p>"},{"location":"python/pre/api/#celldega.pre.save_cbg_gene_parquets--returns","title":"Returns","text":"<p>None</p> Source code in <code>src/celldega/pre/landscape.py</code> <pre><code>def save_cbg_gene_parquets(base_path, cbg, verbose=False):\n    \"\"\"\n    Save the cell-by-gene matrix as gene-specific Parquet files.\n\n    Parameters\n    ----------\n    base_path : str\n        The base path to the parent directory containing the landscape_files directory.\n    cbg : pandas.DataFrame\n        A sparse DataFrame with genes as columns and barcodes as rows.\n    verbose : bool, optional\n        Whether to print progress information, by default False.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    output_dir = os.path.join(base_path, \"cbg\")\n    os.makedirs(output_dir, exist_ok=True)\n\n    for index, gene in enumerate(cbg.columns):\n        if verbose and index % 100 == 0:\n            print(f\"Processing gene {index}: {gene}\")\n\n        # Extract the column as a DataFrame as a copy\n        col_df = cbg[[gene]].copy()\n\n        # Convert to dense and integer type\n        col_df = col_df.sparse.to_dense().astype(int)\n\n        # Create a DataFrame necessary to prevent error in to_parquet\n        inst_df = pd.DataFrame(\n            col_df.values, columns=[gene], index=col_df.index.tolist()\n        )\n\n        # Replace 0 with NA and drop rows where all values are NA\n        inst_df.replace(0, pd.NA, inplace=True)\n        inst_df.dropna(how=\"all\", inplace=True)\n\n        # Save to Parquet if DataFrame is not empty\n        if not inst_df.empty:\n            output_path = os.path.join(output_dir, f\"{gene}.parquet\")\n            inst_df.to_parquet(output_path)\n</code></pre>"},{"location":"python/pre/api/#celldega.pre.save_landscape_parameters","title":"<code>save_landscape_parameters(technology, path_landscape_files, image_name='dapi_files', tile_size=1000, image_info={}, image_format='.webp')</code>","text":"<p>Save the landscape parameters to a JSON file.</p> Source code in <code>src/celldega/pre/__init__.py</code> <pre><code>def save_landscape_parameters(\n    technology, path_landscape_files, image_name=\"dapi_files\", tile_size=1000, image_info={}, image_format='.webp'\n):\n    \"\"\"\n    Save the landscape parameters to a JSON file.\n    \"\"\"\n\n    path_image_pyramid = f\"{path_landscape_files}/pyramid_images/{image_name}\"\n\n    print(path_image_pyramid)\n\n    max_pyramid_zoom = get_max_zoom_level(path_image_pyramid)\n\n    landscape_parameters = {\n        \"technology\": technology,\n        \"max_pyramid_zoom\": max_pyramid_zoom,\n        \"tile_size\": tile_size,\n        \"image_info\": image_info,\n        \"image_format\": image_format\n    }\n\n    path_landscape_parameters = f\"{path_landscape_files}/landscape_parameters.json\"\n\n    with open(path_landscape_parameters, \"w\") as file:\n        json.dump(landscape_parameters, file, indent=4)\n</code></pre>"},{"location":"python/viz/api/","title":"Viz Module API Reference","text":""},{"location":"python/viz/api/#widget-classes","title":"Widget Classes","text":""},{"location":"python/viz/api/#celldega.viz.widget.Landscape","title":"<code>Landscape</code>","text":"<p>               Bases: <code>AnyWidget</code></p> <p>A widget for interactive visualization of spatial omics data. This widget currently supports iST (Xenium and MERSCOPE) and sST (Visium HD data)</p> <p>Parameters:</p> Name Type Description Default <code>ini_x</code> <code>float</code> <p>The initial x-coordinate of the view.</p> required <code>ini_y</code> <code>float</code> <p>The initial y-coordinate of the view.</p> required <code>ini_zoom</code> <code>float</code> <p>The initial zoom level of the view.</p> required <code>token</code> <code>str</code> <p>The token traitlet.</p> required <code>base_url</code> <code>str</code> <p>The base URL for the widget.</p> required <code>dataset_name</code> <code>str</code> <p>The name of the dataset to visualize. This will show up in the user interface bar.</p> required <p>Attributes:</p> Name Type Description <code>component</code> <code>str</code> <p>The name of the component.</p> <code>technology</code> <code>str</code> <p>The technology used.</p> <code>base_url</code> <code>str</code> <p>The base URL for the widget.</p> <code>token</code> <code>str</code> <p>The token traitlet.</p> <code>ini_x</code> <code>float</code> <p>The initial x-coordinate of the view.</p> <code>ini_y</code> <code>float</code> <p>The initial y-coordinate of the view.</p> <code>ini_z</code> <code>float</code> <p>The initial z-coordinate of the view.</p> <code>ini_zoom</code> <code>float</code> <p>The initial zoom level of the view.</p> <code>dataset_name</code> <code>str</code> <p>The name of the dataset to visualize.</p> <code>update_trigger</code> <code>dict</code> <p>The dictionary to trigger updates.</p> <code>cell_clusters</code> <code>dict</code> <p>The dictionary containing cell cluster information.</p> <p>Returns:</p> Name Type Description <code>Landscape</code> <p>A widget for visualizing a 'landscape' view of spatial omics data.</p> Source code in <code>src/celldega/viz/widget.py</code> <pre><code>class Landscape(anywidget.AnyWidget):\n    \"\"\"\n    A widget for interactive visualization of spatial omics data. This widget\n    currently supports iST (Xenium and MERSCOPE) and sST (Visium HD data)\n\n    Args:\n        ini_x (float): The initial x-coordinate of the view.\n        ini_y (float): The initial y-coordinate of the view.\n        ini_zoom (float): The initial zoom level of the view.\n        token (str): The token traitlet.\n        base_url (str): The base URL for the widget.\n        dataset_name (str, optional): The name of the dataset to visualize. This will show up in the user interface bar.\n\n    Attributes:\n        component (str): The name of the component.\n        technology (str): The technology used.\n        base_url (str): The base URL for the widget.\n        token (str): The token traitlet.\n        ini_x (float): The initial x-coordinate of the view.\n        ini_y (float): The initial y-coordinate of the view.\n        ini_z (float): The initial z-coordinate of the view.\n        ini_zoom (float): The initial zoom level of the view.\n        dataset_name (str): The name of the dataset to visualize.\n        update_trigger (dict): The dictionary to trigger updates.\n        cell_clusters (dict): The dictionary containing cell cluster information.\n\n    Returns:\n        Landscape: A widget for visualizing a 'landscape' view of spatial omics data.\n    \"\"\"\n    _esm = pathlib.Path(__file__).parent / \"../static\" / \"widget.js\"\n    _css = pathlib.Path(__file__).parent / \"../static\" / \"widget.css\"\n    component = traitlets.Unicode(\"Landscape\").tag(sync=True)\n\n    technology = traitlets.Unicode(\"sst\").tag(sync=True)\n    base_url = traitlets.Unicode(\"\").tag(sync=True)\n    token = traitlets.Unicode(\"\").tag(sync=True)\n    ini_x = traitlets.Float(1000).tag(sync=True)\n    ini_y = traitlets.Float(1000).tag(sync=True)\n    ini_z = traitlets.Float(0).tag(sync=True)\n    ini_zoom = traitlets.Float(0).tag(sync=True)\n    square_tile_size = traitlets.Float(1.4).tag(sync=True)\n    dataset_name = traitlets.Unicode(\"\").tag(sync=True)\n    region = traitlets.Dict({}).tag(sync=True)\n    nbhd = traitlets.Dict({}).tag(sync=True)\n\n    update_trigger = traitlets.Dict().tag(sync=True)\n    cell_clusters = traitlets.Dict().tag(sync=True)\n\n    width = traitlets.Int(0).tag(sync=True)\n    height = traitlets.Int(800).tag(sync=True)\n\n    def trigger_update(self, new_value):\n        # This method updates the update_trigger traitlet with a new value\n        # You can pass any information necessary for the update, or just a timestamp\n        self.update_trigger = new_value\n\n    def update_cell_clusters(self, new_clusters):\n        # Convert the new_clusters to a JSON serializable format if necessary\n        self.cell_clusters = new_clusters\n</code></pre>"},{"location":"python/viz/api/#celldega.viz.widget.Matrix","title":"<code>Matrix</code>","text":"<p>               Bases: <code>AnyWidget</code></p> <p>A widget for interactive visualization of a hierarchically clustered matrix.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The value traitlet.</p> required <code>component</code> <code>str</code> <p>The component traitlet.</p> required <code>network</code> <code>dict</code> <p>The network traitlet.</p> required <code>click_info</code> <code>dict</code> <p>The click_info traitlet.</p> required <p>Attributes:</p> Name Type Description <code>component</code> <code>str</code> <p>The name of the component.</p> <code>network</code> <code>dict</code> <p>The network dictionary.</p> <code>click_info</code> <code>dict</code> <p>The click_info dictionary.</p> <p>Returns:</p> Name Type Description <code>Matrix</code> <p>A widget for visualizing a hierarchically clustered matrix.</p> Source code in <code>src/celldega/viz/widget.py</code> <pre><code>class Matrix(anywidget.AnyWidget):\n    \"\"\"\n    A widget for interactive visualization of a hierarchically clustered matrix.\n\n    Args:\n        value (int): The value traitlet.\n        component (str): The component traitlet.\n        network (dict): The network traitlet.\n        click_info (dict): The click_info traitlet.\n\n    Attributes:\n        component (str): The name of the component.\n        network (dict): The network dictionary.\n        click_info (dict): The click_info dictionary.\n\n    Returns:\n        Matrix: A widget for visualizing a hierarchically clustered matrix.\n    \"\"\"\n    _esm = pathlib.Path(__file__).parent / \"../static\" / \"widget.js\"\n    _css = pathlib.Path(__file__).parent / \"../static\" / \"widget.css\"\n    value = traitlets.Int(0).tag(sync=True)\n    component = traitlets.Unicode(\"Matrix\").tag(sync=True)\n\n    network = traitlets.Dict({}).tag(sync=True)\n    width = traitlets.Int(600).tag(sync=True)\n    height = traitlets.Int(600).tag(sync=True)\n    click_info = traitlets.Dict({}).tag(sync=True)\n</code></pre>"},{"location":"technologies/","title":"Technologies","text":"<p>Celldega utilizes a suite of complementary technologies to develop an efficient web-based spatial-omics analysis and visualization toolkit.</p>"},{"location":"technologies/#visualization-technologies","title":"Visualization Technologies","text":"<p>Spatial transcriptomics (ST) datasets can be very large and difficult for researchers to analyze and visualize collaboratively. Additionally, visualization that is linked to analysis is key to extracting biological insights. To address these issues, we built the Celldega <code>viz</code> module to help researchers interactively visualize large ST datasets within notebook-based workflows on the cloud (e.g., Terra.bio).</p> <p>The Celldega Landscape visualization method (see Gallery) utilizes novel vector tiling approaches to enable interactive visualization of large ST datasets in a notebook environment or as a stand-alone webpage. This approach allows Celldega to visualize larger datasets than currently available open-source tools (e.g., datasets with hundreds of millions of transcripts). We also utilize modern web image data formats (WebP) to reduce the data storage burden for interactive visualization. The resulting LandscapeFiles data format serves as a compact and highly performant visualization-specific data format.</p>"},{"location":"technologies/#terrabio","title":"Terra.bio","text":"<p>Terra.bio is a cloud-based compute and data storage platform that is being developed by the Broad Institute of MIT and Harvard. We are utilizing Terra.bio to help Spatial Technology Platform clients access, analyze, and visualize their ST data.</p>"},{"location":"technologies/#jupyter-widget","title":"Jupyter Widget","text":"<p>We utilize the Jupyter Widget ecosystem to build interactive spatial and data visualizations that enable users to perform two way communication between JavaScript (front-end) and Python (back-end). We are utilizing the AnyWidget implementation to build our custom widgets.</p>"},{"location":"technologies/#deckgl","title":"Deck.gl","text":"<p>Celldega uses the GPU-powered data visualization library deck.gl to create high-performance spatial- and data-visualizations.</p>"},{"location":"technologies/#apache-parquet","title":"Apache Parquet","text":"<p>Celldega uses the Apache Parquet file format for storing vectorized spatial data and metadata. This file format in combination with the JavaScript library ParquetWASM and Apache Arrow in memory representation is used to build Celldega's high-performance vector tiling spatial visualization functionality (see GeoArrow and GeoParquet in deck.gl).</p>"},{"location":"technologies/#parquetwasm-and-apache-arrow","title":"ParquetWASM and Apache Arrow","text":"<p>ParquetWASM is a JavaScript library for reading Parquet files into Apache Arrow memory and utilizes Web Assembly (WASM) to run Rust in a browser environment. The Apache Arrow in-memory format is a columnar in-memory format that is used for storing data from Apache Parquet files and efficiently passing to deck.gl. For more information please see GeoArrow and GeoParquet in deck.gl.</p>"},{"location":"technologies/#webp","title":"WebP","text":"<p>A modern image format developed by Google, offering efficient lossless compression and designed specifically for the web.</p>"},{"location":"technologies/#deep-zoom","title":"Deep Zoom","text":"<p>We utilize the Deep Zoom image schema, developed by Microsoft, to enable efficient visualization of large multi-channel microscopy images. Deep Zoom tile images are stored using the WebP image format.</p>"},{"location":"technologies/#clustergrammer-visualization-approaches","title":"Clustergrammer Visualization Approaches","text":"<p>The Celldega Matrix visualization builds upon the visualization approaches developed in the Clustergrammer project. This enables users to interactively explore high-dimensional datasets (e.g., single-cell gene expression data) alongside spatial data (e.g., cell distributions within a tissue).</p>"},{"location":"technologies/#data-analysis-technologies","title":"Data Analysis Technologies","text":""},{"location":"technologies/#scanpy-and-squidpy","title":"Scanpy and Squidpy","text":"<p>Celldega is built to interface with the AnnData and SpatialData objects, which enables users to easily import analysis results from Scanpy and Squidpy, respectively, into Celldega for downstream analysis and/or visuaization.</p>"},{"location":"technologies/#geopandas","title":"GeoPandas","text":"<p>Celldega uses GeoPandas for efficient spatial operations and storing collections of spatial objects (e.g., neighborhood multi-polygons) as GeoDataFrames.</p>"},{"location":"technologies/#libpysal-python-spatial-analysis-library-core","title":"LibPySal: Python Spatial Analysis Library Core","text":"<p>Celldega uses the Python Spatial Analysis Library (libpysal) for spatial analysis - namely for calculating alpha shape cell type neighborhoods.</p>"},{"location":"technologies/#clustergrammer-data-analysis-approaches","title":"Clustergrammer Data Analysis Approaches","text":"<p>The Celldega Cluster module build upon the hierarchical clustering approaches developed in the Clustergrammer project. This enables users to perform hierarchical clustering on observations (e.g., single cells) and measurements (e.g., genes) and easily visualize these two orthogonal clustering results interactively using Celldega's Matrix visualization method.</p>"}]}