{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Celldega's Documentation","text":"<p>This is the official documentation for the Celldega library.</p>"},{"location":"#overview","title":"Overview","text":"<ul> <li>Getting Started</li> <li>Installation</li> <li>Usage</li> </ul>"},{"location":"#gallery","title":"Gallery","text":""},{"location":"#embedded-jupyter-notebook","title":"Embedded Jupyter Notebook","text":""},{"location":"gallery/","title":"Gallery","text":"<p>main gallery</p>"},{"location":"gallery_xenium/","title":"Celldega Xenium Gallery","text":""},{"location":"gallery_xenium/#xenium-prime-mouse-brain-coronal-ff","title":"Xenium Prime Mouse Brain Coronal FF","text":""},{"location":"gallery_xenium/#xenium-prime-human-skin-ffpe-outs","title":"Xenium Prime Human Skin FFPE outs","text":""},{"location":"gallery_xenium/#xenium-human-pancreas-ffpe","title":"Xenium Human Pancreas FFPE","text":""},{"location":"gallery_xenium/#bone-marrow","title":"Bone Marrow","text":""},{"location":"gallery_xenium_human_skin/","title":"Xenium Prime Human Skin FFPE outs","text":""},{"location":"gallery_xenium_mouse_brain/","title":"Xenium Prime Mouse Brain Coronal FF","text":""},{"location":"gallery_xenium_multi/","title":"Xenium Multi Dataset","text":""},{"location":"gallery_xenium_multi/#xenium-prime-mouse-brain-coronal-ff","title":"Xenium Prime Mouse Brain Coronal FF","text":""},{"location":"gallery_xenium_multi/#xenium-prime-human-skin-ffpe-outs","title":"Xenium Prime Human Skin FFPE outs","text":""},{"location":"gallery_xenium_multi/#xenium-human-pancreas-ffpe","title":"Xenium Human Pancreas FFPE","text":""},{"location":"gallery_xenium_multi/#bone-marrow","title":"Bone Marrow","text":""},{"location":"getting_started/","title":"Getting Started","text":"<p>Welcome to the Celldega documentation.</p>"},{"location":"usage/","title":"Getting Started","text":"<p>Welcome to the Celldega documentation! Here you will find information on how to get started with using Celldega.</p>"},{"location":"usage/#visualization-example","title":"Visualization Example","text":"<p>Below is an embedded Celldega visualization:</p>"},{"location":"examples/Landscape_View_Xenium/","title":"Landscape View Xenium","text":"In\u00a0[2]: Copied! <pre># %load_ext autoreload\n# %autoreload 2\n# %env ANYWIDGET_HMR=1\n</pre> # %load_ext autoreload # %autoreload 2 # %env ANYWIDGET_HMR=1 In\u00a0[3]: Copied! <pre>import celldega as dega\ndega.__version__\n</pre> import celldega as dega dega.__version__ Out[3]: <pre>'0.0.0'</pre> In\u00a0[6]: Copied! <pre>from observable_jupyter import embed\n</pre> from observable_jupyter import embed In\u00a0[11]: Copied! <pre>base_url = 'https://raw.githubusercontent.com/broadinstitute/celldega_Xenium_Prime_Mouse_Brain_Coronal_FF_outs/main/Xenium_Prime_Mouse_Brain_Coronal_FF_outs'\n</pre> base_url = 'https://raw.githubusercontent.com/broadinstitute/celldega_Xenium_Prime_Mouse_Brain_Coronal_FF_outs/main/Xenium_Prime_Mouse_Brain_Coronal_FF_outs' In\u00a0[14]: Copied! <pre>embed('@cornhundred/celldega-landscape-ist', inputs={'base_url': base_url}, cells=['landscape_container'], display_logo=False)\n</pre> embed('@cornhundred/celldega-landscape-ist', inputs={'base_url': base_url}, cells=['landscape_container'], display_logo=False) In\u00a0[13]: Copied! <pre># base_url = 'https://raw.githubusercontent.com/broadinstitute/celldega_Xenium_Prime_Human_Skin_FFPE_outs/main/Xenium_Prime_Human_Skin_FFPE_outs'\n\n# landscape_ist = dega.viz.Landscape(\n#     technology='Xenium',\n#     ini_zoom = -4.5,\n#     ini_x=6000,\n#     ini_y=8000,\n#     base_url = base_url,\n\n# )\n\n# landscape_ist\n</pre> # base_url = 'https://raw.githubusercontent.com/broadinstitute/celldega_Xenium_Prime_Human_Skin_FFPE_outs/main/Xenium_Prime_Human_Skin_FFPE_outs'  # landscape_ist = dega.viz.Landscape( #     technology='Xenium', #     ini_zoom = -4.5, #     ini_x=6000, #     ini_y=8000, #     base_url = base_url,  # )  # landscape_ist In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/Landscape_View_Xenium/#landscape-view-xenium","title":"Landscape View Xenium\u00b6","text":""},{"location":"python/api/","title":"Python API Reference","text":"<p>Module for pre-processing data</p> <p>Module for visualization</p>"},{"location":"python/api/#celldega.pre.calc_meta_gene_data","title":"<code>calc_meta_gene_data(cbg)</code>","text":"<p>Calculate gene metadata from the cell-by-gene matrix.</p>"},{"location":"python/api/#celldega.pre.calc_meta_gene_data--parameters","title":"Parameters","text":"<p>cbg : pandas.DataFrame     A DataFrame with genes as columns and barcodes as rows. It can be either     sparse or dense.</p>"},{"location":"python/api/#celldega.pre.calc_meta_gene_data--returns","title":"Returns","text":"<p>meta_gene : pandas.DataFrame     A DataFrame containing metadata for each gene, including mean expression,     standard deviation, maximum expression, and proportion of non-zero expressions.</p> Source code in <code>src/celldega/pre/landscape.py</code> <pre><code>def calc_meta_gene_data(cbg):\n    \"\"\"\n    Calculate gene metadata from the cell-by-gene matrix.\n\n    Parameters\n    ----------\n    cbg : pandas.DataFrame\n        A DataFrame with genes as columns and barcodes as rows. It can be either\n        sparse or dense.\n\n    Returns\n    -------\n    meta_gene : pandas.DataFrame\n        A DataFrame containing metadata for each gene, including mean expression,\n        standard deviation, maximum expression, and proportion of non-zero expressions.\n    \"\"\"\n\n    # Helper function to convert to dense if sparse\n    def convert_to_dense(series):\n        \"\"\"\n        Convert a pandas Series to dense format if it's sparse.\n\n        Parameters\n        ----------\n        series : pandas.Series\n\n        Returns\n        -------\n        pandas.Series\n            Dense Series if input was sparse; original Series otherwise.\n        \"\"\"\n        if pd.api.types.is_sparse(series):\n            return series.sparse.to_dense()\n        return series\n\n    # Ensure cbg is a DataFrame\n    if not isinstance(cbg, pd.DataFrame):\n        raise TypeError(\"cbg must be a pandas DataFrame\")\n\n    # Determine if cbg is sparse\n    is_sparse = pd.api.types.is_sparse(cbg)\n\n    if is_sparse:\n        # Ensure cbg has SparseDtype with float and fill_value=0\n        cbg = cbg.astype(pd.SparseDtype(\"float\", fill_value=0))\n        print(\"cbg is a sparse DataFrame. Proceeding with sparse operations.\")\n    else:\n        print(\"cbg is a dense DataFrame. Proceeding with dense operations.\")\n\n    # Calculate mean expression across tiles\n    print(\"Calculating mean expression\")\n    mean_expression = cbg.mean(axis=0)\n\n    # Calculate variance as the average of the squared deviations\n    print(\"Calculating variance\")\n    num_tiles = cbg.shape[1]\n    # Vectorized computation for variance\n    variance = ((cbg - mean_expression) ** 2).sum(axis=0) / num_tiles\n    std_deviation = np.sqrt(variance)\n\n    # Calculate maximum expression\n    print(\"Calculating maximum expression\")\n    max_expression = cbg.max(axis=0)\n\n    # Calculate proportion of tiles with non-zero expression\n    print(\"Calculating proportion of non-zero expression\")\n    proportion_nonzero = (cbg != 0).sum(axis=0) / len(cbg)\n\n    # Create a DataFrame to hold all these metrics\n    meta_gene = pd.DataFrame({\n        \"mean\": convert_to_dense(mean_expression),\n        \"std\": std_deviation,\n        \"max\": convert_to_dense(max_expression),\n        \"non-zero\": convert_to_dense(proportion_nonzero)\n    })\n\n    return meta_gene\n</code></pre>"},{"location":"python/api/#celldega.pre.convert_long_id_to_short","title":"<code>convert_long_id_to_short(df)</code>","text":"<p>Converts a column of long integer cell IDs in a DataFrame to a shorter, hash-based representation.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The DataFrame containing the EntityID.</p> required <p>Returns:     pd.DataFrame: The original DataFrame with an additional column named <code>cell_id</code>                   containing the shortened cell IDs.</p> <p>The function applies a SHA-256 hash to each cell ID, encodes the hash using base64, and truncates it to create a shorter identifier that is added as a new column to the DataFrame.</p> Source code in <code>src/celldega/pre/__init__.py</code> <pre><code>def convert_long_id_to_short(df):\n    \"\"\"\n    Converts a column of long integer cell IDs in a DataFrame to a shorter, hash-based representation.\n\n    Args:\n        df (pd.DataFrame): The DataFrame containing the EntityID.\n    Returns:\n        pd.DataFrame: The original DataFrame with an additional column named `cell_id`\n                      containing the shortened cell IDs.\n\n    The function applies a SHA-256 hash to each cell ID, encodes the hash using base64, and truncates\n    it to create a shorter identifier that is added as a new column to the DataFrame.\n    \"\"\"\n    # Function to hash and encode the cell ID\n    def hash_and_shorten_id(cell_id):\n        # Create a hash of the cell ID\n        cell_id_bytes = str(cell_id).encode('utf-8')\n        hash_object = hashlib.sha256(cell_id_bytes)\n        hash_digest = hash_object.digest()\n\n        # Encode the hash to a base64 string to mix letters and numbers, truncate to 9 characters\n        short_id = base64.urlsafe_b64encode(hash_digest).decode('utf-8')[:9]\n        return short_id\n\n    # Apply the hash_and_shorten_id function to each cell ID in the specified column\n    df['cell_id'] = df['EntityID'].apply(hash_and_shorten_id)\n\n    return df\n</code></pre>"},{"location":"python/api/#celldega.pre.convert_to_jpeg","title":"<code>convert_to_jpeg(image_path, quality=80)</code>","text":"<p>Convert a TIFF image to a JPEG image with a quality of score</p>"},{"location":"python/api/#celldega.pre.convert_to_jpeg--parameters","title":"Parameters","text":"<p>image_path : str     Path to the image file quality : int (default=80)     Quality score for the JPEG image</p>"},{"location":"python/api/#celldega.pre.convert_to_jpeg--returns","title":"Returns","text":"<p>new_image_path : str     Path to the JPEG image file</p> Source code in <code>src/celldega/pre/__init__.py</code> <pre><code>def convert_to_jpeg(image_path, quality=80):\n    \"\"\"\n    Convert a TIFF image to a JPEG image with a quality of score\n\n    Parameters\n    ----------\n    image_path : str\n        Path to the image file\n    quality : int (default=80)\n        Quality score for the JPEG image\n\n    Returns\n    -------\n    new_image_path : str\n        Path to the JPEG image file\n\n    \"\"\"\n\n    # Load the TIFF image\n    image = pyvips.Image.new_from_file(image_path, access=\"sequential\")\n\n    # Save the image as a JPEG with a quality of 80\n    new_image_path = image_path.replace(\".tif\", \".jpeg\")\n    image.jpegsave(new_image_path, Q=quality)\n\n    return new_image_path\n</code></pre>"},{"location":"python/api/#celldega.pre.convert_to_png","title":"<code>convert_to_png(image_path)</code>","text":"<p>Convert a TIFF image to a JPEG image with a quality of score</p>"},{"location":"python/api/#celldega.pre.convert_to_png--parameters","title":"Parameters","text":"<p>image_path : str     Path to the image file quality : int (default=80)     Quality score for the JPEG image</p>"},{"location":"python/api/#celldega.pre.convert_to_png--returns","title":"Returns","text":"<p>new_image_path : str     Path to the JPEG image file</p> Source code in <code>src/celldega/pre/__init__.py</code> <pre><code>def convert_to_png(image_path):\n    \"\"\"\n    Convert a TIFF image to a JPEG image with a quality of score\n\n    Parameters\n    ----------\n    image_path : str\n        Path to the image file\n    quality : int (default=80)\n        Quality score for the JPEG image\n\n    Returns\n    -------\n    new_image_path : str\n        Path to the JPEG image file\n\n    \"\"\"\n\n    # Load the TIFF image\n    image = pyvips.Image.new_from_file(image_path, access=\"sequential\")\n\n    # Save the image as a JPEG with a quality of 80\n    new_image_path = image_path.replace(\".tif\", \".png\")\n    image.pngsave(new_image_path)\n\n    return new_image_path\n</code></pre>"},{"location":"python/api/#celldega.pre.convert_to_webp","title":"<code>convert_to_webp(image_path, quality=100)</code>","text":"<p>Convert a TIFF image to a WEBP image with a specified quality score.</p>"},{"location":"python/api/#celldega.pre.convert_to_webp--parameters","title":"Parameters","text":"<p>image_path : str     Path to the image file quality : int (default=100)     Quality score for the WEBP image (higher is better quality)</p>"},{"location":"python/api/#celldega.pre.convert_to_webp--returns","title":"Returns","text":"<p>new_image_path : str     Path to the WEBP image file</p> Source code in <code>src/celldega/pre/__init__.py</code> <pre><code>def convert_to_webp(image_path, quality=100):\n    \"\"\"\n    Convert a TIFF image to a WEBP image with a specified quality score.\n\n    Parameters\n    ----------\n    image_path : str\n        Path to the image file\n    quality : int (default=100)\n        Quality score for the WEBP image (higher is better quality)\n\n    Returns\n    -------\n    new_image_path : str\n        Path to the WEBP image file\n    \"\"\"\n    # Load the TIFF image\n    image = pyvips.Image.new_from_file(image_path, access=\"sequential\")\n\n    # Save the image as a WEBP with specified quality\n    new_image_path = image_path.replace(\".tif\", \".webp\")\n    image.webpsave(new_image_path, Q=quality)\n\n    return new_image_path\n</code></pre>"},{"location":"python/api/#celldega.pre.get_max_zoom_level","title":"<code>get_max_zoom_level(path_image_pyramid)</code>","text":"<p>Returns the maximum zoom level based on the highest-numbered directory in the specified path_image_pyramid.</p> <p>Parameters:</p> Name Type Description Default <code>path_image_pyramid</code> <code>str</code> <p>The path to the directory containing zoom level directories.</p> required <p>Returns:</p> Name Type Description <code>max_pyramid_zoom</code> <code>int</code> <p>The maximum zoom level.</p> Source code in <code>src/celldega/pre/__init__.py</code> <pre><code>def get_max_zoom_level(path_image_pyramid):\n    \"\"\"\n    Returns the maximum zoom level based on the highest-numbered directory\n    in the specified path_image_pyramid.\n\n    Parameters:\n        path_image_pyramid (str): The path to the directory containing zoom level directories.\n\n    Returns:\n        max_pyramid_zoom (int): The maximum zoom level.\n    \"\"\"\n    # List all entries in the path_image_pyramid that are directories and can be converted to integers\n    zoom_levels = [\n        entry\n        for entry in os.listdir(path_image_pyramid)\n        if os.path.isdir(os.path.join(path_image_pyramid, entry)) and entry.isdigit()\n    ]\n\n    # Convert to integer and find the maximum value\n    max_pyramid_zoom = max(map(int, zoom_levels)) if zoom_levels else None\n\n    return max_pyramid_zoom\n</code></pre>"},{"location":"python/api/#celldega.pre.make_cell_boundary_tiles","title":"<code>make_cell_boundary_tiles(technology, path_cell_boundaries, path_meta_cell_micron, path_transformation_matrix, path_output, coarse_tile_size=5000, fine_tile_size=250, tile_bounds=None, image_scale=1, max_workers=8)</code>","text":"<p>Processes cell boundary data and divides it into spatial tiles based on the provided technology. Reads cell boundary data, applies affine transformations, and divides the data into coarse and fine tiles. The resulting tiles are saved as Parquet files, each containing the geometries of cells in that tile.</p>"},{"location":"python/api/#celldega.pre.make_cell_boundary_tiles--parameters","title":"Parameters","text":"<p>technology : str     The technology used to generate the cell boundary data, e.g., \"MERSCOPE\", \"Xenium\", or \"custom\". path_cell_boundaries : str     Path to the file containing the cell boundaries (Parquet format). path_meta_cell_micron : str     Path to the file containing cell metadata (CSV format). path_transformation_matrix : str     Path to the file containing the transformation matrix (CSV format). path_output : str     Directory path where the output files (Parquet files) for each tile will be saved. coarse_tile_size : int, optional, default=5000     Size of each coarse-grain tile in microns. fine_tile_size : int, optional, default=500     Size of each fine-grain tile in microns. tile_bounds : dict, optional     Dictionary containing the minimum and maximum bounds for x and y coordinates. image_scale : float, optional, default=1     Scale factor to apply to the geometry data. max_workers : int, optional, default=8     Maximum number of parallel workers for processing tiles.</p>"},{"location":"python/api/#celldega.pre.make_cell_boundary_tiles--returns","title":"Returns","text":"<p>None</p> Source code in <code>src/celldega/pre/boundary_tile.py</code> <pre><code>def make_cell_boundary_tiles(\n    technology,\n    path_cell_boundaries,\n    path_meta_cell_micron,\n    path_transformation_matrix,\n    path_output,\n    coarse_tile_size=5000,\n    fine_tile_size=250,\n    tile_bounds=None,\n    image_scale=1,\n    max_workers=8\n):\n\n\n    \"\"\"\n    Processes cell boundary data and divides it into spatial tiles based on the provided technology.\n    Reads cell boundary data, applies affine transformations, and divides the data into coarse and fine tiles.\n    The resulting tiles are saved as Parquet files, each containing the geometries of cells in that tile.\n\n    Parameters\n    ----------\n    technology : str\n        The technology used to generate the cell boundary data, e.g., \"MERSCOPE\", \"Xenium\", or \"custom\".\n    path_cell_boundaries : str\n        Path to the file containing the cell boundaries (Parquet format).\n    path_meta_cell_micron : str\n        Path to the file containing cell metadata (CSV format).\n    path_transformation_matrix : str\n        Path to the file containing the transformation matrix (CSV format).\n    path_output : str\n        Directory path where the output files (Parquet files) for each tile will be saved.\n    coarse_tile_size : int, optional, default=5000\n        Size of each coarse-grain tile in microns.\n    fine_tile_size : int, optional, default=500\n        Size of each fine-grain tile in microns.\n    tile_bounds : dict, optional\n        Dictionary containing the minimum and maximum bounds for x and y coordinates.\n    image_scale : float, optional, default=1\n        Scale factor to apply to the geometry data.\n    max_workers : int, optional, default=8\n        Maximum number of parallel workers for processing tiles.\n\n    Returns\n    -------\n    None\n    \"\"\"\n\n    def numpy_affine_transform(coords, matrix):\n        \"\"\"Apply affine transformation to numpy coordinates.\"\"\"\n        # Homogeneous coordinates for affine transformation\n        coords = np.hstack([coords, np.ones((coords.shape[0], 1))])\n        transformed_coords = coords @ matrix.T\n        return transformed_coords[:, :2]  # Drop the homogeneous coordinate\n\n    def batch_transform_geometries(geometries, transformation_matrix, scale):\n        \"\"\"\n        Batch transform geometries using numpy for optimized performance.\n        \"\"\"\n        # Extract affine transformation parameters into a 3x3 matrix for numpy\n        affine_matrix = np.array([\n            [transformation_matrix[0, 0], transformation_matrix[0, 1], transformation_matrix[0, 2]],\n            [transformation_matrix[1, 0], transformation_matrix[1, 1], transformation_matrix[1, 2]],\n            [0, 0, 1]\n        ])\n\n        transformed_geometries = []\n\n        for polygon in geometries:\n            # Extract coordinates and transform them\n            if isinstance(polygon, MultiPolygon):\n                polygon = next(polygon.geoms)  # Use the first geometry\n\n            # Transform the exterior of the polygon\n            exterior_coords = np.array(polygon.exterior.coords)\n\n            # Apply the affine transformation and scale\n            transformed_coords = numpy_affine_transform(exterior_coords, affine_matrix) / scale\n\n            # Append the result to the transformed_geometries list\n            transformed_geometries.append([transformed_coords.tolist()])\n\n        return transformed_geometries\n\n\n    def filter_and_save_fine_boundary(coarse_tile, fine_i, fine_j, fine_tile_x_min, fine_tile_x_max, fine_tile_y_min, fine_tile_y_max, path_output):\n        cell_ids = coarse_tile.index.values\n\n        tile_filter = (\n            (coarse_tile[\"center_x\"] &gt;= fine_tile_x_min) &amp; (coarse_tile[\"center_x\"] &lt; fine_tile_x_max) &amp;\n            (coarse_tile[\"center_y\"] &gt;= fine_tile_y_min) &amp; (coarse_tile[\"center_y\"] &lt; fine_tile_y_max)\n        )\n        filtered_indices = np.where(tile_filter)[0]\n\n        keep_cells = cell_ids[filtered_indices]\n        fine_tile_cells = coarse_tile.loc[keep_cells, [\"GEOMETRY\"]]\n        fine_tile_cells = fine_tile_cells.assign(name=fine_tile_cells.index)\n\n        if not fine_tile_cells.empty:\n            filename = f\"{path_output}/cell_tile_{fine_i}_{fine_j}.parquet\"\n            fine_tile_cells.to_parquet(filename)\n\n    def process_fine_boundaries(coarse_tile, i, j, coarse_tile_x_min, coarse_tile_x_max, coarse_tile_y_min, coarse_tile_y_max, fine_tile_size, path_output, x_min, y_min, n_fine_tiles_x, n_fine_tiles_y):\n        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:\n            futures = []\n            for fine_i in range(n_fine_tiles_x):\n                fine_tile_x_min = x_min + fine_i * fine_tile_size\n                fine_tile_x_max = fine_tile_x_min + fine_tile_size\n\n                if not (fine_tile_x_min &gt;= coarse_tile_x_min and fine_tile_x_max &lt;= coarse_tile_x_max):\n                    continue\n\n                for fine_j in range(n_fine_tiles_y):\n                    fine_tile_y_min = y_min + fine_j * fine_tile_size\n                    fine_tile_y_max = fine_tile_y_min + fine_tile_size\n\n                    if not (fine_tile_y_min &gt;= coarse_tile_y_min and fine_tile_y_max &lt;= coarse_tile_y_max):\n                        continue\n\n                    futures.append(executor.submit(\n                        filter_and_save_fine_boundary, coarse_tile, fine_i, fine_j, fine_tile_x_min, fine_tile_x_max, fine_tile_y_min, fine_tile_y_max, path_output\n                    ))\n\n            for future in futures:\n                future.result()\n\n    tile_size_x = fine_tile_size\n    tile_size_y = fine_tile_size\n\n    transformation_matrix = pd.read_csv(path_transformation_matrix, header=None, sep=\" \").values\n\n    # Load cell boundary data based on the technology\n    if technology == \"MERSCOPE\":\n        df_meta = pd.read_parquet(f\"{path_output.replace('cell_segmentation','cell_metadata.parquet')}\")\n        entity_to_cell_id_dict = pd.Series(df_meta.index.values, index=df_meta.EntityID).to_dict()\n        cells_orig = gpd.read_parquet(path_cell_boundaries)\n        cells_orig['cell_id'] = cells_orig['EntityID'].map(entity_to_cell_id_dict)\n        cells_orig = cells_orig[cells_orig[\"ZIndex\"] == 1]\n\n        # Correct cell_id issues with meta_cell\n        meta_cell = pd.read_csv(path_meta_cell_micron)\n        meta_cell['cell_id'] = meta_cell['EntityID'].map(entity_to_cell_id_dict)\n        cells_orig.index = meta_cell[meta_cell[\"cell_id\"].isin(cells_orig['cell_id'])].index\n\n        # Correct 'MultiPolygon' to 'Polygon'\n        cells_orig[\"geometry\"] = cells_orig[\"Geometry\"].apply(\n            lambda x: list(x.geoms)[0] if isinstance(x, MultiPolygon) else x\n        )\n\n        cells_orig.set_index('cell_id', inplace=True)\n\n    elif technology == \"Xenium\":\n        xenium_cells = pd.read_parquet(path_cell_boundaries)\n        grouped = xenium_cells.groupby(\"cell_id\")[[\"vertex_x\", \"vertex_y\"]].agg(lambda x: x.tolist())\n        grouped[\"geometry\"] = grouped.apply(lambda row: Polygon(zip(row[\"vertex_x\"], row[\"vertex_y\"])), axis=1)\n        cells_orig = gpd.GeoDataFrame(grouped, geometry=\"geometry\")[[\"geometry\"]]\n\n    elif technology == \"custom\":\n        cells_orig = gpd.read_parquet(path_cell_boundaries)\n\n    # Transform geometries\n    cells_orig[\"GEOMETRY\"] = batch_transform_geometries(cells_orig[\"geometry\"], transformation_matrix, image_scale)\n\n    # Convert transformed geometries to polygons and calculate centroids\n    cells_orig[\"polygon\"] = cells_orig[\"GEOMETRY\"].apply(lambda x: Polygon(x[0]))\n    gdf_cells = gpd.GeoDataFrame(geometry=cells_orig[\"polygon\"])\n    gdf_cells[\"center_x\"] = gdf_cells.geometry.centroid.x\n    gdf_cells[\"center_y\"] = gdf_cells.geometry.centroid.y\n    gdf_cells[\"GEOMETRY\"] = cells_orig[\"GEOMETRY\"]\n\n    # Ensure the output directory exists\n    if not os.path.exists(path_output):\n        os.makedirs(path_output)\n\n    # Calculate tile bounds and fine/coarse tiles\n    x_min, x_max = tile_bounds[\"x_min\"], tile_bounds[\"x_max\"]\n    y_min, y_max = tile_bounds[\"y_min\"], tile_bounds[\"y_max\"]\n    n_fine_tiles_x = int(np.ceil((x_max - x_min) / fine_tile_size))\n    n_fine_tiles_y = int(np.ceil((y_max - y_min) / fine_tile_size))\n    n_coarse_tiles_x = int(np.ceil((x_max - x_min) / coarse_tile_size))\n    n_coarse_tiles_y = int(np.ceil((y_max - y_min) / coarse_tile_size))\n\n    # Process coarse tiles in parallel\n    for i in tqdm(range(n_coarse_tiles_x), desc=\"Processing coarse tiles\"):\n        coarse_tile_x_min = x_min + i * coarse_tile_size\n        coarse_tile_x_max = coarse_tile_x_min + coarse_tile_size\n\n        for j in range(n_coarse_tiles_y):\n            coarse_tile_y_min = y_min + j * coarse_tile_size\n            coarse_tile_y_max = coarse_tile_y_min + coarse_tile_size\n\n            coarse_tile = gdf_cells[\n                (gdf_cells[\"center_x\"] &gt;= coarse_tile_x_min) &amp; (gdf_cells[\"center_x\"] &lt; coarse_tile_x_max) &amp;\n                (gdf_cells[\"center_y\"] &gt;= coarse_tile_y_min) &amp; (gdf_cells[\"center_y\"] &lt; coarse_tile_y_max)\n            ]\n            if not coarse_tile.empty:\n                process_fine_boundaries(coarse_tile, i, j, coarse_tile_x_min, coarse_tile_x_max, coarse_tile_y_min, coarse_tile_y_max, fine_tile_size, path_output, x_min, y_min, n_fine_tiles_x, n_fine_tiles_y)\n</code></pre>"},{"location":"python/api/#celldega.pre.make_deepzoom_pyramid","title":"<code>make_deepzoom_pyramid(image_path, output_path, pyramid_name, tile_size=512, overlap=0, suffix='.jpeg')</code>","text":"<p>Create a DeepZoom image pyramid from a JPEG image</p>"},{"location":"python/api/#celldega.pre.make_deepzoom_pyramid--parameters","title":"Parameters","text":"<p>image_path : str     Path to the JPEG image file tile_size : int (default=512)     Tile size for the DeepZoom pyramid overlap : int (default=0)     Overlap size for the DeepZoom pyramid suffix : str (default='jpeg')     Suffix for the DeepZoom pyramid tiles</p>"},{"location":"python/api/#celldega.pre.make_deepzoom_pyramid--returns","title":"Returns","text":"<p>None</p> Source code in <code>src/celldega/pre/__init__.py</code> <pre><code>def make_deepzoom_pyramid(\n    image_path, output_path, pyramid_name, tile_size=512, overlap=0, suffix=\".jpeg\"\n):\n    \"\"\"\n    Create a DeepZoom image pyramid from a JPEG image\n\n    Parameters\n    ----------\n    image_path : str\n        Path to the JPEG image file\n    tile_size : int (default=512)\n        Tile size for the DeepZoom pyramid\n    overlap : int (default=0)\n        Overlap size for the DeepZoom pyramid\n    suffix : str (default='jpeg')\n        Suffix for the DeepZoom pyramid tiles\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n\n    # Define the output path\n    output_path = Path(output_path)\n\n    # Load the JPEG image\n    image = pyvips.Image.new_from_file(image_path, access=\"sequential\")\n\n    # check if the output path exists and create it if it does not\n    output_path.mkdir(parents=True, exist_ok=True)\n\n    # append the pyramid name to the output path\n    output_path = output_path / pyramid_name\n\n    # Save the image as a DeepZoom image pyramid\n    image.dzsave(output_path, tile_size=tile_size, overlap=overlap, suffix=suffix)\n</code></pre>"},{"location":"python/api/#celldega.pre.make_meta_cell_image_coord","title":"<code>make_meta_cell_image_coord(technology, path_transformation_matrix, path_meta_cell_micron, path_meta_cell_image, image_scale)</code>","text":"<p>Apply an affine transformation to the cell coordinates in microns and save the transformed coordinates in pixels</p>"},{"location":"python/api/#celldega.pre.make_meta_cell_image_coord--parameters","title":"Parameters","text":"<p>technology : str     The technology used to generate the data, Xenium and MERSCOPE are supported. path_transformation_matrix : str     Path to the transformation matrix file path_meta_cell_micron : str     Path to the meta cell file with coordinates in microns path_meta_cell_image : str     Path to save the meta cell file with coordinates in pixels</p>"},{"location":"python/api/#celldega.pre.make_meta_cell_image_coord--returns","title":"Returns","text":"<p>None</p>"},{"location":"python/api/#celldega.pre.make_meta_cell_image_coord--examples","title":"Examples","text":"<p>make_meta_cell_image_coord( ...     technology='Xenium', ...     path_transformation_matrix='data/transformation_matrix.txt', ...     path_meta_cell_micron='data/meta_cell_micron.csv', ...     path_meta_cell_image='data/meta_cell_image.parquet' ... )</p> Source code in <code>src/celldega/pre/__init__.py</code> <pre><code>def make_meta_cell_image_coord(\n    technology,\n    path_transformation_matrix,\n    path_meta_cell_micron,\n    path_meta_cell_image,\n    image_scale\n):\n    \"\"\"\n    Apply an affine transformation to the cell coordinates in microns and save\n    the transformed coordinates in pixels\n\n    Parameters\n    ----------\n    technology : str\n        The technology used to generate the data, Xenium and MERSCOPE are supported.\n    path_transformation_matrix : str\n        Path to the transformation matrix file\n    path_meta_cell_micron : str\n        Path to the meta cell file with coordinates in microns\n    path_meta_cell_image : str\n        Path to save the meta cell file with coordinates in pixels\n\n    Returns\n    -------\n    None\n\n    Examples\n    --------\n    &gt;&gt;&gt; make_meta_cell_image_coord(\n    ...     technology='Xenium',\n    ...     path_transformation_matrix='data/transformation_matrix.txt',\n    ...     path_meta_cell_micron='data/meta_cell_micron.csv',\n    ...     path_meta_cell_image='data/meta_cell_image.parquet'\n    ... )\n\n    \"\"\"\n\n    transformation_matrix = pd.read_csv(\n        path_transformation_matrix, header=None, sep=\" \"\n    ).values\n\n    if technology == \"MERSCOPE\":\n        meta_cell = pd.read_csv(path_meta_cell_micron, usecols=[\"EntityID\", \"center_x\", \"center_y\"])\n        meta_cell = convert_long_id_to_short(meta_cell)\n        meta_cell[\"name\"] =  meta_cell[\"cell_id\"]\n        meta_cell = meta_cell.set_index('cell_id')\n    elif technology == \"Xenium\":\n        usecols = [\"cell_id\", \"x_centroid\", \"y_centroid\"]\n        meta_cell = pd.read_csv(path_meta_cell_micron, index_col=0, usecols=usecols)\n        meta_cell.columns = [\"center_x\", \"center_y\"]\n        meta_cell[\"name\"] = pd.Series(meta_cell.index, index=meta_cell.index)\n\n    # Adding a ones column to accommodate for affine transformation\n    meta_cell[\"ones\"] = 1\n\n    # Preparing the data for matrix multiplication\n    points = meta_cell[[\"center_x\", \"center_y\", \"ones\"]].values\n\n    # Applying the transformation matrix\n    transformed_points = np.dot(transformation_matrix, points.T).T\n\n    # Updating the DataFrame with transformed coordinates\n    meta_cell[\"center_x\"] = transformed_points[:, 0]\n    meta_cell[\"center_y\"] = transformed_points[:, 1]\n\n    # Dropping the ones column as it's no longer needed\n    meta_cell.drop(columns=[\"ones\"], inplace=True)\n\n    meta_cell[\"center_x\"] = meta_cell[\"center_x\"] / image_scale\n    meta_cell[\"center_y\"] = meta_cell[\"center_y\"] / image_scale\n\n    meta_cell[\"geometry\"] = meta_cell.apply(\n        lambda row: [row[\"center_x\"], row[\"center_y\"]], axis=1\n    )\n\n    if technology == \"MERSCOPE\":\n        meta_cell = meta_cell[[\"name\", \"geometry\", \"EntityID\"]]\n    else:\n        meta_cell = meta_cell[[\"name\", \"geometry\"]]\n\n\n    meta_cell.to_parquet(path_meta_cell_image)\n</code></pre>"},{"location":"python/api/#celldega.pre.make_meta_gene","title":"<code>make_meta_gene(technology, path_cbg, path_output)</code>","text":"<p>Create a DataFrame with genes and their assigned colors</p>"},{"location":"python/api/#celldega.pre.make_meta_gene--parameters","title":"Parameters","text":"<p>technology : str     The technology used to generate the data, Xenium and MERSCOPE are supported. path_cbg : str     Path to the cell-by-gene matrix data (the data format can vary based on technology) path_output : str     Path to save the meta gene file</p>"},{"location":"python/api/#celldega.pre.make_meta_gene--returns","title":"Returns","text":"<p>None</p>"},{"location":"python/api/#celldega.pre.make_meta_gene--examples","title":"Examples","text":"<p>make_meta_gene( ...     technology='Xenium', ...     path_cbg='data/', ...     path_output='data/meta_gene.parquet' ... )</p> Source code in <code>src/celldega/pre/__init__.py</code> <pre><code>def make_meta_gene(technology, path_cbg, path_output):\n    \"\"\"\n    Create a DataFrame with genes and their assigned colors\n\n    Parameters\n    ----------\n    technology : str\n        The technology used to generate the data, Xenium and MERSCOPE are supported.\n    path_cbg : str\n        Path to the cell-by-gene matrix data (the data format can vary based on technology)\n    path_output : str\n        Path to save the meta gene file\n\n    Returns\n    -------\n    None\n\n    Examples\n    --------\n    &gt;&gt;&gt; make_meta_gene(\n    ...     technology='Xenium',\n    ...     path_cbg='data/',\n    ...     path_output='data/meta_gene.parquet'\n    ... )\n    \"\"\"\n\n    if technology == \"MERSCOPE\":\n        cbg = pd.read_csv(path_cbg, index_col=0)\n        genes = cbg.columns.tolist()\n    elif technology == \"Xenium\":\n        # genes = pd.read_csv(path_cbg + 'features.tsv.gz', sep='\\t', header=None)[1].values.tolist()\n        cbg = read_cbg_mtx(path_cbg)\n        genes = cbg.columns.tolist()\n\n    # Get all categorical color palettes from Matplotlib and flatten them into a single list of colors\n    palettes = [plt.get_cmap(name).colors for name in plt.colormaps() if \"tab\" in name]\n    flat_colors = [color for palette in palettes for color in palette]\n\n    # Convert RGB tuples to hex codes\n    flat_colors_hex = [to_hex(color) for color in flat_colors]\n\n    # Use modular arithmetic to assign a color to each gene, white for genes with \"Blank\"\n    colors = [\n        flat_colors_hex[i % len(flat_colors_hex)] if \"Blank\" not in gene else \"#FFFFFF\"\n        for i, gene in enumerate(genes)\n    ]\n\n    # Create a DataFrame with genes and their assigned colors\n    ser_color = pd.Series(colors, index=genes)\n\n    # calculate gene expression metadata\n    meta_gene = calc_meta_gene_data(cbg)\n    meta_gene['color'] = ser_color\n\n    # Identify sparse columns\n    sparse_cols = [col for col in meta_gene.columns if pd.api.types.is_sparse(meta_gene[col])]\n\n    # Convert sparse columns to dense\n    for col in sparse_cols:\n        meta_gene[col] = meta_gene[col].sparse.to_dense()\n\n    meta_gene.to_parquet(path_output)\n</code></pre>"},{"location":"python/api/#celldega.pre.make_trx_tiles","title":"<code>make_trx_tiles(technology, path_trx, path_transformation_matrix, path_trx_tiles, coarse_tile_size=2500, fine_tile_size=250, chunk_size=1000000, verbose=False, image_scale=1, max_workers=8)</code>","text":"<p>Processes transcript data by dividing it into coarse-grain and fine-grain tiles, applying transformations, and saving the results in a parallelized manner.</p>"},{"location":"python/api/#celldega.pre.make_trx_tiles--parameters","title":"Parameters","text":"<p>technology : str     The technology used for generating the transcript data (e.g., \"MERSCOPE\" or \"Xenium\"). path_trx : str     Path to the file containing the transcript data. path_transformation_matrix : str     Path to the file containing the transformation matrix (CSV file). path_trx_tiles : str     Directory path where the output files (Parquet files) for each tile will be saved. coarse_tile_size : int, optional     Size of each coarse-grain tile in microns (default is 2500). fine_tile_size : int, optional     Size of each fine-grain tile in microns (default is 250). chunk_size : int, optional     Number of rows to process per chunk for memory efficiency (default is 1000000). verbose : bool, optional     Flag to enable verbose output (default is False). image_scale : float, optional     Scale factor to apply to the transcript coordinates (default is 0.5). max_workers : int, optional     Maximum number of parallel workers for processing tiles (default is 8).</p>"},{"location":"python/api/#celldega.pre.make_trx_tiles--returns","title":"Returns","text":"<p>dict     A dictionary containing the bounds of the processed data in both x and y directions.</p> Source code in <code>src/celldega/pre/trx_tile.py</code> <pre><code>def make_trx_tiles(\n    technology,\n    path_trx,\n    path_transformation_matrix,\n    path_trx_tiles,\n    coarse_tile_size=2500,\n    fine_tile_size=250,\n    chunk_size=1000000,\n    verbose=False,\n    image_scale=1,\n    max_workers=8\n):\n    \"\"\"\n    Processes transcript data by dividing it into coarse-grain and fine-grain tiles,\n    applying transformations, and saving the results in a parallelized manner.\n\n    Parameters\n    ----------\n    technology : str\n        The technology used for generating the transcript data (e.g., \"MERSCOPE\" or \"Xenium\").\n    path_trx : str\n        Path to the file containing the transcript data.\n    path_transformation_matrix : str\n        Path to the file containing the transformation matrix (CSV file).\n    path_trx_tiles : str\n        Directory path where the output files (Parquet files) for each tile will be saved.\n    coarse_tile_size : int, optional\n        Size of each coarse-grain tile in microns (default is 2500).\n    fine_tile_size : int, optional\n        Size of each fine-grain tile in microns (default is 250).\n    chunk_size : int, optional\n        Number of rows to process per chunk for memory efficiency (default is 1000000).\n    verbose : bool, optional\n        Flag to enable verbose output (default is False).\n    image_scale : float, optional\n        Scale factor to apply to the transcript coordinates (default is 0.5).\n    max_workers : int, optional\n        Maximum number of parallel workers for processing tiles (default is 8).\n\n    Returns\n    -------\n    dict\n        A dictionary containing the bounds of the processed data in both x and y directions.\n    \"\"\"\n\n    def process_coarse_tile(trx, i, j, coarse_tile_x_min, coarse_tile_x_max, coarse_tile_y_min, coarse_tile_y_max, fine_tile_size, path_trx_tiles, x_min, y_min, n_fine_tiles_x, n_fine_tiles_y, max_workers):\n        # Filter the entire dataset for the current coarse tile\n        coarse_tile = trx.filter(\n            (pl.col(\"transformed_x\") &gt;= coarse_tile_x_min) &amp; (pl.col(\"transformed_x\") &lt; coarse_tile_x_max) &amp;\n            (pl.col(\"transformed_y\") &gt;= coarse_tile_y_min) &amp; (pl.col(\"transformed_y\") &lt; coarse_tile_y_max)\n        )\n\n        if not coarse_tile.is_empty():\n            # Now process fine tiles using global fine tile indices\n            process_fine_tiles(coarse_tile, i, j, coarse_tile_x_min, coarse_tile_x_max, coarse_tile_y_min, coarse_tile_y_max, fine_tile_size, path_trx_tiles, x_min, y_min, n_fine_tiles_x, n_fine_tiles_y, max_workers)   \n\n\n    def process_fine_tiles(coarse_tile, coarse_i, coarse_j, coarse_tile_x_min, coarse_tile_x_max, coarse_tile_y_min, coarse_tile_y_max, fine_tile_size, path_trx_tiles, x_min, y_min, n_fine_tiles_x, n_fine_tiles_y, max_workers=8):\n\n        # Use ThreadPoolExecutor for parallel processing of fine-grain tiles within the coarse tile\n        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:\n            futures = []\n\n            # Iterate over fine-grain tiles within the global bounds\n            for fine_i in range(n_fine_tiles_x):\n                fine_tile_x_min = x_min + fine_i * fine_tile_size\n                fine_tile_x_max = fine_tile_x_min + fine_tile_size\n\n                # Process only if the fine tile falls within the current coarse tile's bounds\n                if not (fine_tile_x_min &gt;= coarse_tile_x_min and fine_tile_x_max &lt;= coarse_tile_x_max):\n                    continue\n\n                for fine_j in range(n_fine_tiles_y):\n                    fine_tile_y_min = y_min + fine_j * fine_tile_size\n                    fine_tile_y_max = fine_tile_y_min + fine_tile_size\n\n                    # Process only if the fine tile falls within the current coarse tile's bounds\n                    if not (fine_tile_y_min &gt;= coarse_tile_y_min and fine_tile_y_max &lt;= coarse_tile_y_max):\n                        continue\n\n                    # Submit the task for each fine tile to process in parallel\n                    futures.append(executor.submit(\n                        filter_and_save_fine_tile, coarse_tile, coarse_i, coarse_j, fine_i, fine_j, \n                        fine_tile_x_min, fine_tile_x_max, fine_tile_y_min, fine_tile_y_max, path_trx_tiles\n                    ))\n\n            # Wait for all futures to complete\n            for future in concurrent.futures.as_completed(futures):\n                future.result()  # Raise exceptions if any occurred during execution\n\n\n    def filter_and_save_fine_tile(coarse_tile, coarse_i, coarse_j, fine_i, fine_j, fine_tile_x_min, fine_tile_x_max, fine_tile_y_min, fine_tile_y_max, path_trx_tiles):\n\n        # Filter the coarse tile for the current fine tile's boundaries\n        fine_tile_trx = coarse_tile.filter(\n            (pl.col(\"transformed_x\") &gt;= fine_tile_x_min) &amp; (pl.col(\"transformed_x\") &lt; fine_tile_x_max) &amp;\n            (pl.col(\"transformed_y\") &gt;= fine_tile_y_min) &amp; (pl.col(\"transformed_y\") &lt; fine_tile_y_max)\n        )\n\n        if not fine_tile_trx.is_empty():\n            # Add geometry column as a list of [x, y] pairs\n            fine_tile_trx = fine_tile_trx.with_columns(\n                pl.concat_list([pl.col(\"transformed_x\"), pl.col(\"transformed_y\")]).alias(\"geometry\")\n            ).drop(['transformed_x', 'transformed_y'])\n\n            # Define the filename based on fine tile coordinates\n            filename = f\"{path_trx_tiles}/transcripts_tile_{fine_i}_{fine_j}.parquet\"\n\n            # Save the filtered DataFrame to a Parquet file\n            fine_tile_trx.to_pandas().to_parquet(filename)\n\n\n    # Load transformation matrix\n    transformation_matrix = np.loadtxt(path_transformation_matrix)\n\n    # Load the transcript data based on the technology using Polars\n    if technology == \"MERSCOPE\":\n        trx_ini = pl.read_csv(path_trx, columns=[\"gene\", \"global_x\", \"global_y\"])\n        trx_ini = trx_ini.with_columns([\n            pl.col(\"global_x\").alias(\"x\"),\n            pl.col(\"global_y\").alias(\"y\"),\n            pl.col(\"gene\").alias(\"name\")\n        ]).select([\"name\", \"x\", \"y\"])\n\n    elif technology == \"Xenium\":\n        trx_ini = pl.read_parquet(path_trx).select([\n            pl.col(\"feature_name\").alias(\"name\"),\n            pl.col(\"x_location\").alias(\"x\"),\n            pl.col(\"y_location\").alias(\"y\")\n        ])\n\n    # Process the data in chunks and apply transformations\n    all_chunks = []\n\n    for start_row in tqdm(range(0, trx_ini.height, chunk_size), desc=\"Processing chunks\"):\n        chunk = trx_ini.slice(start_row, chunk_size)\n\n        # Apply transformation matrix to the coordinates\n        points = np.hstack([chunk.select([\"x\", \"y\"]).to_numpy(), np.ones((chunk.height, 1))])\n        transformed_points = np.dot(points, transformation_matrix.T)[:, :2]\n\n        # Create new transformed columns and drop original x, y columns\n        transformed_chunk = chunk.with_columns([\n            (pl.Series(transformed_points[:, 0]) * image_scale).round(2).alias(\"transformed_x\"),\n            (pl.Series(transformed_points[:, 1]) * image_scale).round(2).alias(\"transformed_y\")\n        ]).drop([\"x\", \"y\"])\n        all_chunks.append(transformed_chunk)\n\n    # Concatenate all chunks after processing\n    trx = pl.concat(all_chunks)\n\n    # Ensure the output directory exists\n    if not os.path.exists(path_trx_tiles):\n        os.makedirs(path_trx_tiles)\n\n    # Get min and max x, y values\n    x_min, x_max = trx.select([\n        pl.col(\"transformed_x\").min().alias(\"x_min\"),\n        pl.col(\"transformed_x\").max().alias(\"x_max\")\n    ]).row(0)\n\n    y_min, y_max = trx.select([\n        pl.col(\"transformed_y\").min().alias(\"y_min\"),\n        pl.col(\"transformed_y\").max().alias(\"y_max\")\n    ]).row(0)\n\n    # Calculate the number of fine-grain tiles globally\n    n_fine_tiles_x = int(np.ceil((x_max - x_min) / fine_tile_size))\n    n_fine_tiles_y = int(np.ceil((y_max - y_min) / fine_tile_size))\n\n    # Calculate the number of coarse-grain tiles\n    n_coarse_tiles_x = int(np.ceil((x_max - x_min) / coarse_tile_size))\n    n_coarse_tiles_y = int(np.ceil((y_max - y_min) / coarse_tile_size))\n\n    # Use ThreadPoolExecutor for parallel processing of coarse-grain tiles\n    with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:\n        futures = []\n        for i in range(n_coarse_tiles_x):\n            coarse_tile_x_min = x_min + i * coarse_tile_size\n            coarse_tile_x_max = coarse_tile_x_min + coarse_tile_size\n\n            for j in range(n_coarse_tiles_y):\n                coarse_tile_y_min = y_min + j * coarse_tile_size\n                coarse_tile_y_max = coarse_tile_y_min + coarse_tile_size\n\n                # Submit each coarse tile for parallel processing\n                futures.append(executor.submit(\n                    process_coarse_tile, trx, i, j, coarse_tile_x_min, coarse_tile_x_max, coarse_tile_y_min, coarse_tile_y_max, fine_tile_size, path_trx_tiles, x_min, y_min, n_fine_tiles_x, n_fine_tiles_y, max_workers\n                ))\n\n        # Wait for all coarse tiles to complete\n        for future in tqdm(concurrent.futures.as_completed(futures), desc=\"Processing coarse tiles\", unit=\"tile\"):\n            future.result()  # Raise exceptions if any occurred during execution\n\n    # Return the tile bounds\n    tile_bounds = {\n        \"x_min\": x_min,\n        \"x_max\": x_max,\n        \"y_min\": y_min,\n        \"y_max\": y_max,\n    }\n\n    return tile_bounds\n</code></pre>"},{"location":"python/api/#celldega.pre.read_cbg_mtx","title":"<code>read_cbg_mtx(base_path)</code>","text":"<p>Read the cell-by-gene matrix from the mtx files.</p>"},{"location":"python/api/#celldega.pre.read_cbg_mtx--parameters","title":"Parameters","text":"<p>base_path : str     The base path to the directory containing the mtx files.</p>"},{"location":"python/api/#celldega.pre.read_cbg_mtx--returns","title":"Returns","text":"<p>cbg : pandas.DataFrame     A sparse DataFrame with genes as columns and barcodes as rows.</p> Source code in <code>src/celldega/pre/landscape.py</code> <pre><code>def read_cbg_mtx(base_path):\n    \"\"\"\n    Read the cell-by-gene matrix from the mtx files.\n\n    Parameters\n    ----------\n    base_path : str\n        The base path to the directory containing the mtx files.\n\n    Returns\n    -------\n    cbg : pandas.DataFrame\n        A sparse DataFrame with genes as columns and barcodes as rows.\n    \"\"\"\n    print(\"Reading mtx file from \", base_path)\n\n    # File paths\n    barcodes_path = os.path.join(base_path, \"barcodes.tsv.gz\")\n    features_path = os.path.join(base_path, \"features.tsv.gz\")\n    matrix_path = os.path.join(base_path, \"matrix.mtx.gz\")\n\n    # Read barcodes and features\n    barcodes = pd.read_csv(barcodes_path, header=None, compression=\"gzip\")\n    features = pd.read_csv(features_path, header=None, compression=\"gzip\", sep=\"\\t\")\n\n    # Read the gene expression matrix and transpose it\n    # Transpose and convert to CSC format for fast column slicing\n    matrix = mmread(matrix_path).transpose().tocsc()\n\n    # Create a sparse DataFrame with genes as columns and barcodes as rows\n    cbg = pd.DataFrame.sparse.from_spmatrix(\n        matrix, index=barcodes[0], columns=features[1]\n    )\n    cbg = cbg.rename_axis('__index_level_0__', axis='columns')\n\n    return cbg\n</code></pre>"},{"location":"python/api/#celldega.pre.reduce_image_size","title":"<code>reduce_image_size(image_path, scale_image=0.5, path_landscape_files='')</code>","text":""},{"location":"python/api/#celldega.pre.reduce_image_size--parameters","title":"Parameters","text":"<p>image_path : str     Path to the image file scale_image : float (default=0.5)     Scale factor for the image resize</p>"},{"location":"python/api/#celldega.pre.reduce_image_size--returns","title":"Returns","text":"<p>new_image_path : str     Path to the resized image file</p> Source code in <code>src/celldega/pre/__init__.py</code> <pre><code>def reduce_image_size(image_path, scale_image=0.5, path_landscape_files=\"\"):\n    \"\"\"\n\n    Parameters\n    ----------\n    image_path : str\n        Path to the image file\n    scale_image : float (default=0.5)\n        Scale factor for the image resize\n\n    Returns\n    -------\n    new_image_path : str\n        Path to the resized image file\n    \"\"\"\n\n    image = pyvips.Image.new_from_file(image_path, access=\"sequential\")\n\n    resized_image = image.resize(scale_image)\n\n    new_image_name = image_path.split(\"/\")[-1].replace(\".tif\", \"_downsize.tif\")\n    new_image_path = f\"{path_landscape_files}/{new_image_name}\"\n    resized_image.write_to_file(new_image_path)\n\n    return new_image_path\n</code></pre>"},{"location":"python/api/#celldega.pre.save_cbg_gene_parquets","title":"<code>save_cbg_gene_parquets(base_path, cbg, verbose=False)</code>","text":"<p>Save the cell-by-gene matrix as gene-specific Parquet files.</p>"},{"location":"python/api/#celldega.pre.save_cbg_gene_parquets--parameters","title":"Parameters","text":"<p>base_path : str     The base path to the parent directory containing the landscape_files directory. cbg : pandas.DataFrame     A sparse DataFrame with genes as columns and barcodes as rows. verbose : bool, optional     Whether to print progress information, by default False.</p>"},{"location":"python/api/#celldega.pre.save_cbg_gene_parquets--returns","title":"Returns","text":"<p>None</p> Source code in <code>src/celldega/pre/landscape.py</code> <pre><code>def save_cbg_gene_parquets(base_path, cbg, verbose=False):\n    \"\"\"\n    Save the cell-by-gene matrix as gene-specific Parquet files.\n\n    Parameters\n    ----------\n    base_path : str\n        The base path to the parent directory containing the landscape_files directory.\n    cbg : pandas.DataFrame\n        A sparse DataFrame with genes as columns and barcodes as rows.\n    verbose : bool, optional\n        Whether to print progress information, by default False.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    output_dir = os.path.join(base_path, \"cbg\")\n    os.makedirs(output_dir, exist_ok=True)\n\n    for index, gene in enumerate(cbg.columns):\n        if verbose and index % 100 == 0:\n            print(f\"Processing gene {index}: {gene}\")\n\n        # Extract the column as a DataFrame as a copy\n        col_df = cbg[[gene]].copy()\n\n        # Convert to dense and integer type\n        col_df = col_df.sparse.to_dense().astype(int)\n\n        # Create a DataFrame necessary to prevent error in to_parquet\n        inst_df = pd.DataFrame(\n            col_df.values, columns=[gene], index=col_df.index.tolist()\n        )\n\n        # Replace 0 with NA and drop rows where all values are NA\n        inst_df.replace(0, pd.NA, inplace=True)\n        inst_df.dropna(how=\"all\", inplace=True)\n\n        # Save to Parquet if DataFrame is not empty\n        if not inst_df.empty:\n            output_path = os.path.join(output_dir, f\"{gene}.parquet\")\n            inst_df.to_parquet(output_path)\n</code></pre>"},{"location":"python/api/#celldega.viz.Landscape","title":"<code>Landscape</code>","text":"<p>               Bases: <code>AnyWidget</code></p> <p>A widget for visualizing a 'landscape' view of spatial omics data.</p> <p>Parameters:</p> Name Type Description Default <code>ini_x</code> <code>float</code> <p>The initial x-coordinate of the view.</p> required <code>ini_y</code> <code>float</code> <p>The initial y-coordinate of the view.</p> required <code>ini_zoom</code> <code>float</code> <p>The initial zoom level of the view.</p> required <code>bounce_time</code> <code>int</code> <p>The time taken for the view to bounce back after panning.</p> required <code>token</code> <code>str</code> <p>The token traitlet.</p> required <code>base_url</code> <code>str</code> <p>The base URL for the widget.</p> required <code>dataset_name</code> <code>str</code> <p>The name of the dataset to visualize. This will show up in the user interface bar.</p> required <p>Attributes:</p> Name Type Description <code>component</code> <code>str</code> <p>The name of the component.</p> <code>technology</code> <code>str</code> <p>The technology used.</p> <code>base_url</code> <code>str</code> <p>The base URL for the widget.</p> <code>token</code> <code>str</code> <p>The token traitlet.</p> <code>ini_x</code> <code>float</code> <p>The initial x-coordinate of the view.</p> <code>ini_y</code> <code>float</code> <p>The initial y-coordinate of the view.</p> <code>ini_z</code> <code>float</code> <p>The initial z-coordinate of the view.</p> <code>ini_zoom</code> <code>float</code> <p>The initial zoom level of the view.</p> <code>dataset_name</code> <code>str</code> <p>The name of the dataset to visualize.</p> <code>update_trigger</code> <code>dict</code> <p>The dictionary to trigger updates.</p> <code>cell_clusters</code> <code>dict</code> <p>The dictionary containing cell cluster information.</p> <p>Returns:</p> Name Type Description <code>Landscape</code> <p>A widget for visualizing a 'landscape' view of spatial omics data.</p> Source code in <code>src/celldega/viz/widget.py</code> <pre><code>class Landscape(anywidget.AnyWidget):\n    \"\"\"\n    A widget for visualizing a 'landscape' view of spatial omics data.\n\n    Args:\n        ini_x (float): The initial x-coordinate of the view.\n        ini_y (float): The initial y-coordinate of the view.\n        ini_zoom (float): The initial zoom level of the view.\n        bounce_time (int): The time taken for the view to bounce back after panning.\n        token (str): The token traitlet.\n        base_url (str): The base URL for the widget.\n        dataset_name (str, optional): The name of the dataset to visualize. This will show up in the user interface bar.\n\n    Attributes:\n        component (str): The name of the component.\n        technology (str): The technology used.\n        base_url (str): The base URL for the widget.\n        token (str): The token traitlet.\n        ini_x (float): The initial x-coordinate of the view.\n        ini_y (float): The initial y-coordinate of the view.\n        ini_z (float): The initial z-coordinate of the view.\n        ini_zoom (float): The initial zoom level of the view.\n        dataset_name (str): The name of the dataset to visualize.\n        update_trigger (dict): The dictionary to trigger updates.\n        cell_clusters (dict): The dictionary containing cell cluster information.\n\n    Returns:\n        Landscape: A widget for visualizing a 'landscape' view of spatial omics data.\n    \"\"\"\n    _esm = pathlib.Path(__file__).parent / \"../static\" / \"widget.js\"\n    _css = pathlib.Path(__file__).parent / \"../static\" / \"widget.css\"\n    component = traitlets.Unicode(\"Landscape\").tag(sync=True)\n\n    technology = traitlets.Unicode(\"sst\").tag(sync=True)\n    base_url = traitlets.Unicode(\"\").tag(sync=True)\n    token = traitlets.Unicode(\"\").tag(sync=True)\n    ini_x = traitlets.Float(1000).tag(sync=True)\n    ini_y = traitlets.Float(1000).tag(sync=True)\n    ini_z = traitlets.Float(0).tag(sync=True)\n    ini_zoom = traitlets.Float(0).tag(sync=True)\n    square_tile_size = traitlets.Float(1.4).tag(sync=True)\n    dataset_name = traitlets.Unicode(\"\").tag(sync=True)\n    region = traitlets.Dict({}).tag(sync=True)\n\n    update_trigger = traitlets.Dict().tag(sync=True)\n    cell_clusters = traitlets.Dict().tag(sync=True)\n\n    width = traitlets.Int(0).tag(sync=True)\n    height = traitlets.Int(800).tag(sync=True)\n\n    def trigger_update(self, new_value):\n        # This method updates the update_trigger traitlet with a new value\n        # You can pass any information necessary for the update, or just a timestamp\n        self.update_trigger = new_value\n\n    def update_cell_clusters(self, new_clusters):\n        # Convert the new_clusters to a JSON serializable format if necessary\n        self.cell_clusters = new_clusters\n</code></pre>"},{"location":"python/pre/api/","title":"Pre Module API Reference","text":""},{"location":"python/pre/api/#landscape-functions","title":"Landscape Functions","text":""},{"location":"python/pre/api/#celldega.pre.landscape.calc_meta_gene_data","title":"<code>calc_meta_gene_data(cbg)</code>","text":"<p>Calculate gene metadata from the cell-by-gene matrix.</p>"},{"location":"python/pre/api/#celldega.pre.landscape.calc_meta_gene_data--parameters","title":"Parameters","text":"<p>cbg : pandas.DataFrame     A DataFrame with genes as columns and barcodes as rows. It can be either     sparse or dense.</p>"},{"location":"python/pre/api/#celldega.pre.landscape.calc_meta_gene_data--returns","title":"Returns","text":"<p>meta_gene : pandas.DataFrame     A DataFrame containing metadata for each gene, including mean expression,     standard deviation, maximum expression, and proportion of non-zero expressions.</p> Source code in <code>src/celldega/pre/landscape.py</code> <pre><code>def calc_meta_gene_data(cbg):\n    \"\"\"\n    Calculate gene metadata from the cell-by-gene matrix.\n\n    Parameters\n    ----------\n    cbg : pandas.DataFrame\n        A DataFrame with genes as columns and barcodes as rows. It can be either\n        sparse or dense.\n\n    Returns\n    -------\n    meta_gene : pandas.DataFrame\n        A DataFrame containing metadata for each gene, including mean expression,\n        standard deviation, maximum expression, and proportion of non-zero expressions.\n    \"\"\"\n\n    # Helper function to convert to dense if sparse\n    def convert_to_dense(series):\n        \"\"\"\n        Convert a pandas Series to dense format if it's sparse.\n\n        Parameters\n        ----------\n        series : pandas.Series\n\n        Returns\n        -------\n        pandas.Series\n            Dense Series if input was sparse; original Series otherwise.\n        \"\"\"\n        if pd.api.types.is_sparse(series):\n            return series.sparse.to_dense()\n        return series\n\n    # Ensure cbg is a DataFrame\n    if not isinstance(cbg, pd.DataFrame):\n        raise TypeError(\"cbg must be a pandas DataFrame\")\n\n    # Determine if cbg is sparse\n    is_sparse = pd.api.types.is_sparse(cbg)\n\n    if is_sparse:\n        # Ensure cbg has SparseDtype with float and fill_value=0\n        cbg = cbg.astype(pd.SparseDtype(\"float\", fill_value=0))\n        print(\"cbg is a sparse DataFrame. Proceeding with sparse operations.\")\n    else:\n        print(\"cbg is a dense DataFrame. Proceeding with dense operations.\")\n\n    # Calculate mean expression across tiles\n    print(\"Calculating mean expression\")\n    mean_expression = cbg.mean(axis=0)\n\n    # Calculate variance as the average of the squared deviations\n    print(\"Calculating variance\")\n    num_tiles = cbg.shape[1]\n    # Vectorized computation for variance\n    variance = ((cbg - mean_expression) ** 2).sum(axis=0) / num_tiles\n    std_deviation = np.sqrt(variance)\n\n    # Calculate maximum expression\n    print(\"Calculating maximum expression\")\n    max_expression = cbg.max(axis=0)\n\n    # Calculate proportion of tiles with non-zero expression\n    print(\"Calculating proportion of non-zero expression\")\n    proportion_nonzero = (cbg != 0).sum(axis=0) / len(cbg)\n\n    # Create a DataFrame to hold all these metrics\n    meta_gene = pd.DataFrame({\n        \"mean\": convert_to_dense(mean_expression),\n        \"std\": std_deviation,\n        \"max\": convert_to_dense(max_expression),\n        \"non-zero\": convert_to_dense(proportion_nonzero)\n    })\n\n    return meta_gene\n</code></pre>"},{"location":"python/pre/api/#celldega.pre.landscape.read_cbg_mtx","title":"<code>read_cbg_mtx(base_path)</code>","text":"<p>Read the cell-by-gene matrix from the mtx files.</p>"},{"location":"python/pre/api/#celldega.pre.landscape.read_cbg_mtx--parameters","title":"Parameters","text":"<p>base_path : str     The base path to the directory containing the mtx files.</p>"},{"location":"python/pre/api/#celldega.pre.landscape.read_cbg_mtx--returns","title":"Returns","text":"<p>cbg : pandas.DataFrame     A sparse DataFrame with genes as columns and barcodes as rows.</p> Source code in <code>src/celldega/pre/landscape.py</code> <pre><code>def read_cbg_mtx(base_path):\n    \"\"\"\n    Read the cell-by-gene matrix from the mtx files.\n\n    Parameters\n    ----------\n    base_path : str\n        The base path to the directory containing the mtx files.\n\n    Returns\n    -------\n    cbg : pandas.DataFrame\n        A sparse DataFrame with genes as columns and barcodes as rows.\n    \"\"\"\n    print(\"Reading mtx file from \", base_path)\n\n    # File paths\n    barcodes_path = os.path.join(base_path, \"barcodes.tsv.gz\")\n    features_path = os.path.join(base_path, \"features.tsv.gz\")\n    matrix_path = os.path.join(base_path, \"matrix.mtx.gz\")\n\n    # Read barcodes and features\n    barcodes = pd.read_csv(barcodes_path, header=None, compression=\"gzip\")\n    features = pd.read_csv(features_path, header=None, compression=\"gzip\", sep=\"\\t\")\n\n    # Read the gene expression matrix and transpose it\n    # Transpose and convert to CSC format for fast column slicing\n    matrix = mmread(matrix_path).transpose().tocsc()\n\n    # Create a sparse DataFrame with genes as columns and barcodes as rows\n    cbg = pd.DataFrame.sparse.from_spmatrix(\n        matrix, index=barcodes[0], columns=features[1]\n    )\n    cbg = cbg.rename_axis('__index_level_0__', axis='columns')\n\n    return cbg\n</code></pre>"},{"location":"python/pre/api/#celldega.pre.landscape.save_cbg_gene_parquets","title":"<code>save_cbg_gene_parquets(base_path, cbg, verbose=False)</code>","text":"<p>Save the cell-by-gene matrix as gene-specific Parquet files.</p>"},{"location":"python/pre/api/#celldega.pre.landscape.save_cbg_gene_parquets--parameters","title":"Parameters","text":"<p>base_path : str     The base path to the parent directory containing the landscape_files directory. cbg : pandas.DataFrame     A sparse DataFrame with genes as columns and barcodes as rows. verbose : bool, optional     Whether to print progress information, by default False.</p>"},{"location":"python/pre/api/#celldega.pre.landscape.save_cbg_gene_parquets--returns","title":"Returns","text":"<p>None</p> Source code in <code>src/celldega/pre/landscape.py</code> <pre><code>def save_cbg_gene_parquets(base_path, cbg, verbose=False):\n    \"\"\"\n    Save the cell-by-gene matrix as gene-specific Parquet files.\n\n    Parameters\n    ----------\n    base_path : str\n        The base path to the parent directory containing the landscape_files directory.\n    cbg : pandas.DataFrame\n        A sparse DataFrame with genes as columns and barcodes as rows.\n    verbose : bool, optional\n        Whether to print progress information, by default False.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    output_dir = os.path.join(base_path, \"cbg\")\n    os.makedirs(output_dir, exist_ok=True)\n\n    for index, gene in enumerate(cbg.columns):\n        if verbose and index % 100 == 0:\n            print(f\"Processing gene {index}: {gene}\")\n\n        # Extract the column as a DataFrame as a copy\n        col_df = cbg[[gene]].copy()\n\n        # Convert to dense and integer type\n        col_df = col_df.sparse.to_dense().astype(int)\n\n        # Create a DataFrame necessary to prevent error in to_parquet\n        inst_df = pd.DataFrame(\n            col_df.values, columns=[gene], index=col_df.index.tolist()\n        )\n\n        # Replace 0 with NA and drop rows where all values are NA\n        inst_df.replace(0, pd.NA, inplace=True)\n        inst_df.dropna(how=\"all\", inplace=True)\n\n        # Save to Parquet if DataFrame is not empty\n        if not inst_df.empty:\n            output_path = os.path.join(output_dir, f\"{gene}.parquet\")\n            inst_df.to_parquet(output_path)\n</code></pre>"},{"location":"python/pre/overview/","title":"Pre Module Overview","text":"<p>The <code>pre</code> module contains functions and classes for pre-processing data.</p>"},{"location":"python/pre/overview/#submodules","title":"Submodules","text":"<ul> <li><code>landscape</code>: Functions related to landscape operations.</li> <li><code>init</code>: Initialization functions and utilities.</li> </ul>"},{"location":"python/viz/api/","title":"Viz Module API Reference","text":""},{"location":"python/viz/api/#widget-classes","title":"Widget Classes","text":""},{"location":"python/viz/api/#celldega.viz.widget.Landscape","title":"<code>Landscape</code>","text":"<p>               Bases: <code>AnyWidget</code></p> <p>A widget for visualizing a 'landscape' view of spatial omics data.</p> <p>Parameters:</p> Name Type Description Default <code>ini_x</code> <code>float</code> <p>The initial x-coordinate of the view.</p> required <code>ini_y</code> <code>float</code> <p>The initial y-coordinate of the view.</p> required <code>ini_zoom</code> <code>float</code> <p>The initial zoom level of the view.</p> required <code>bounce_time</code> <code>int</code> <p>The time taken for the view to bounce back after panning.</p> required <code>token</code> <code>str</code> <p>The token traitlet.</p> required <code>base_url</code> <code>str</code> <p>The base URL for the widget.</p> required <code>dataset_name</code> <code>str</code> <p>The name of the dataset to visualize. This will show up in the user interface bar.</p> required <p>Attributes:</p> Name Type Description <code>component</code> <code>str</code> <p>The name of the component.</p> <code>technology</code> <code>str</code> <p>The technology used.</p> <code>base_url</code> <code>str</code> <p>The base URL for the widget.</p> <code>token</code> <code>str</code> <p>The token traitlet.</p> <code>ini_x</code> <code>float</code> <p>The initial x-coordinate of the view.</p> <code>ini_y</code> <code>float</code> <p>The initial y-coordinate of the view.</p> <code>ini_z</code> <code>float</code> <p>The initial z-coordinate of the view.</p> <code>ini_zoom</code> <code>float</code> <p>The initial zoom level of the view.</p> <code>dataset_name</code> <code>str</code> <p>The name of the dataset to visualize.</p> <code>update_trigger</code> <code>dict</code> <p>The dictionary to trigger updates.</p> <code>cell_clusters</code> <code>dict</code> <p>The dictionary containing cell cluster information.</p> <p>Returns:</p> Name Type Description <code>Landscape</code> <p>A widget for visualizing a 'landscape' view of spatial omics data.</p> Source code in <code>src/celldega/viz/widget.py</code> <pre><code>class Landscape(anywidget.AnyWidget):\n    \"\"\"\n    A widget for visualizing a 'landscape' view of spatial omics data.\n\n    Args:\n        ini_x (float): The initial x-coordinate of the view.\n        ini_y (float): The initial y-coordinate of the view.\n        ini_zoom (float): The initial zoom level of the view.\n        bounce_time (int): The time taken for the view to bounce back after panning.\n        token (str): The token traitlet.\n        base_url (str): The base URL for the widget.\n        dataset_name (str, optional): The name of the dataset to visualize. This will show up in the user interface bar.\n\n    Attributes:\n        component (str): The name of the component.\n        technology (str): The technology used.\n        base_url (str): The base URL for the widget.\n        token (str): The token traitlet.\n        ini_x (float): The initial x-coordinate of the view.\n        ini_y (float): The initial y-coordinate of the view.\n        ini_z (float): The initial z-coordinate of the view.\n        ini_zoom (float): The initial zoom level of the view.\n        dataset_name (str): The name of the dataset to visualize.\n        update_trigger (dict): The dictionary to trigger updates.\n        cell_clusters (dict): The dictionary containing cell cluster information.\n\n    Returns:\n        Landscape: A widget for visualizing a 'landscape' view of spatial omics data.\n    \"\"\"\n    _esm = pathlib.Path(__file__).parent / \"../static\" / \"widget.js\"\n    _css = pathlib.Path(__file__).parent / \"../static\" / \"widget.css\"\n    component = traitlets.Unicode(\"Landscape\").tag(sync=True)\n\n    technology = traitlets.Unicode(\"sst\").tag(sync=True)\n    base_url = traitlets.Unicode(\"\").tag(sync=True)\n    token = traitlets.Unicode(\"\").tag(sync=True)\n    ini_x = traitlets.Float(1000).tag(sync=True)\n    ini_y = traitlets.Float(1000).tag(sync=True)\n    ini_z = traitlets.Float(0).tag(sync=True)\n    ini_zoom = traitlets.Float(0).tag(sync=True)\n    square_tile_size = traitlets.Float(1.4).tag(sync=True)\n    dataset_name = traitlets.Unicode(\"\").tag(sync=True)\n    region = traitlets.Dict({}).tag(sync=True)\n\n    update_trigger = traitlets.Dict().tag(sync=True)\n    cell_clusters = traitlets.Dict().tag(sync=True)\n\n    width = traitlets.Int(0).tag(sync=True)\n    height = traitlets.Int(800).tag(sync=True)\n\n    def trigger_update(self, new_value):\n        # This method updates the update_trigger traitlet with a new value\n        # You can pass any information necessary for the update, or just a timestamp\n        self.update_trigger = new_value\n\n    def update_cell_clusters(self, new_clusters):\n        # Convert the new_clusters to a JSON serializable format if necessary\n        self.cell_clusters = new_clusters\n</code></pre>"},{"location":"python/viz/overview/","title":"Viz Module Overview","text":"<p>The <code>viz</code> module contains functions and classes for data visualization.</p>"},{"location":"python/viz/overview/#submodules","title":"Submodules","text":"<ul> <li><code>widget</code>: Widgets for visualizing spatial omics data.</li> </ul>"}]}